### ts 基础学习

安装，编译

```shell
npm i typescript -g

# tsc helloworld.ts # 这样不会就近找配置文件

tsc

tsc -watch # 能持续监听，如有变化就编译
```

如需要自动编译监听运行 ts，也可选用 ts-node

```shell
npm i ts-node -g

# 编译，运行，并输出结果
ts-node helloworld.ts
```

tsconfig.json 文件，ts 配置文件

```javascript
// tsconfig.json
const config = {
  compilerOptions: {
    /* Basic Options */
    target:
      "es5" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. 指定ECMAScript的目标版本*/,
    module:
      "commonjs" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. 指定模块代码的生成方式*/,
    // "lib": [],                             /* Specify library files to be included in the compilation. 指定编译的时候用来包含的编译文件*/
    // "allowJs": true,                       /* Allow javascript files to be compiled. 允许编译JS文件*/
    // "checkJs": true,                       /* Report errors in .js files. 在JS中包括错误*/
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. 指定JSX代码的生成方式 是保留还是react-native或者react*/
    // "declaration": true,                   /* Generates corresponding '.d.ts' file.生成相应的类型声明文件 */
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. 为每个类型声明文件生成相应的sourcemap*/
    // "sourceMap": true,                     /* Generates corresponding '.map' file. 生成对应的map文件 */
    // "outFile": "./",                       /* Concatenate and emit output to single file. 合并并且把编译后的内容输出 到一个文件里*/
    // "outDir": "./",                        /* Redirect output structure to the directory.按原始结构输出到目标目录 */
    // "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. 指定输入文件的根目录，用--outDir来控制输出的目录结构*/
    // "composite": true,                     /* Enable project compilation 启用项目编译*/
    // "removeComments": true,                /* Do not emit comments to output. 移除注释*/
    // "noEmit": true,                        /* Do not emit outputs. 不要输出*/
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. 当目标是ES5或ES3的时候提供对for-of、扩展运算符和解构赋值中对于迭代器的完整支持*/
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule').r把每一个文件转译成一个单独的模块 */

    /* Strict Type-Checking Options */
    //"strict": true,                           /* Enable all strict type-checking options. 启用完全的严格类型检查 */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. 不能使用隐式的any类型*/
    // "strictNullChecks": true,              /* Enable strict null checks. 启用严格的NULL检查*/
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. 启用严格的函数类型检查*/
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions.启用函数上严格的bind call 和apply方法 */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. 启用类上初始化属性检查*/
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type.在默认的any中调用 this表达式报错 */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. 在严格模式下解析并且向每个源文件中发射use strict*/

    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. 有未使用到的本地变量时报错 */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. 有未使用到的参数时报错*/
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. 当不是所有的代码路径都有返回值的时候报错*/
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. 在switch表达式中没有替代的case会报错 */

    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). 指定模块的解析策略 node classic*/
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. 在解析非绝对路径模块名的时候的基准路径*/
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. 一些路径的集合*/
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. 根目录的列表，在运行时用来合并内容*/
    // "typeRoots": [],                       /* List of folders to include type definitions from. 用来包含类型声明的文件夹列表*/
    // "types": [],                           /* Type declaration files to be included in compilation.在编译的时候被包含的类型声明 */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking.当没有默认导出的时候允许默认导入，这个在代码执行的时候没有作用，只是在类型检查的时候生效 */
    //"esModuleInterop": true                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'.*/
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks.不要symlinks解析的真正路径 */

    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. 指定ts文件位置*/
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. 指定 map文件存放的位置 */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. 源文件和sourcemap 文件在同一文件中，而不是把map文件放在一个单独的文件里*/
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. 源文件和sourcemap 文件在同一文件中*/

    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. 启动装饰器*/
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */
  },
};
```

### 1. 数据类型

#### 1.1 布尔类型(boolean)

```typescript
let married: boolean = false;
```

#### 1.2 数字类型(number)

```typescript
let age: number = 10;
```

#### 1.3 字符串类型(string)

```typescript
let firstname: string = "Jack";
```

#### 1.4 数组类型(array)

```typescript
let arr2: number[] = [4, 5, 6];
let arr3: Array<number> = [7, 8, 9];
```

#### 1.5 元组类型(tuple)

在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组

```typescript
let tuple: [string, number] = ["tuple", 5];
tuple[0].length;
tuple[1].toFixed(2);
```

|          元组          |         数组         |
| :--------------------: | :------------------: |
| 每一项可以是不同的类型 | 每一项都是同一种类型 |
|     有预定义的长度     |     没有长度限制     |
|    用于表示一个结构    |   用于表示一个列表   |

```typescript
const animal: [string, number, boolean] = ["cat", 10, true];
```

#### 1.6 枚举类型(enum)

事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值 比如性别、月份、星期、颜色、单位、学历

#### 1.6.1 普通枚举

```typescript
enum Gender {
  GIRL,
  BOY,
}

console.log(`Jack${Gender.BOY}`);
console.log(`Rose${Gender.GIRL}`);

enum Week {
  MONDAY = 1,
  TUESDAY = 2,
}

console.log(`今天是星期${Week.MONDAY}`);
```

#### 1.6.2 常数枚举

常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。

假如包含了计算成员，则会在编译阶段报错

枚举常量不会编译出函数，而是常量，提高性能。如果只是申明未使用将编译出空，使用部分只编译出部分。

```typescript
const enum Colors {
  Red,
  Yellow,
  Blue,
}

let myColors = [Colors.Red, Colors.Yellow, Colors.Blue];

const enum Color {
  Red,
  Yellow,
  Blue = "blue".length,
} // 这里会报错
// const enum member initializers can only contain literal values and other computed enum values.
```

#### 1.7 任意类型(any)

any 就是可以赋值给任意类型

第三方库没有提供类型文件时可以使用 any

类型转换遇到困难时

数据结构太复杂难以定义

```typescript
let root: any = document.getElementById("root");
root.style.color = "red";

// 这里只是举个例子，实际上这里应该用ts内建类型
let root2: HTMLElement = document.getElementById("root2");
```

3.8 null 和 undefined

null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined

strictNullChecks // 一般会开启

```typescript
// strictNullChecks = false
let x: number;
x = 1;
x = undefined;
x = null;

// strictNullChecks = true
let y: number | null | undefined;
y = 1;
y = undefined;
y = null;
```

#### 1.9 void 类型

void 表示没有任何类型

当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。

当我们声明一个变量类型是 void 的时候，它的非严格模式下仅可以被赋值为 null 和 undefined;

严格模式 仅为 undefined（此处严格模式指的时 ts 中的 strictNullChecks 配置）

```typescript
function greeting(name: string): void {
  console.log("hello", name);
}

greeting("boy");
```

#### 1.10 never 类型

never 是其它类型(null undefined)的子类型，代表不会出现的值

#### 1.10.1

作为不会返回（ return ）的函数的返回值类型

// 返回 never 的函数 必须存在 无法达到（ unreachable ） 的终点

```typescript
function error(message: string): never {
  throw new Error(message);
}
```

// 由类型推论得到返回值为 never

```typescript
function fail() {
  return error("Something failed");
}

// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点
function infiniteLoop(): never {
  while (true) {}
}
```

#### 1.10.2 strictNullChecks

在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。
于是 TS 引入了 --strictNullChecks 这一种检查模式

由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。
所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。

// Compiled with --strictNullChecks

```typescript
function fn(x: propType) {
  if (typeof x === "number") {
    // x: number 类型
  } else if (typeof x === "string") {
    // x: string 类型
  } else {
    // x: never 类型
    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察
  }
}
```

一种适用场景

```typescript
// strictNullChecks 配置为true
type AllPropType = number | string;
function handleValue(val: propType) {
  switch (val.type) {
    case "number":
      // 这里 val 被收窄为 number
      break;
    case "string":
      // val 在这里是 string
      break;
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val;
      break;
  }
}
```

但是假如后来有一天你的同事改了 propType 的类型：

type AllPropType = number | string | boolean

然而他忘记了在 handleValue 里面加上针对 boolean 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 boolean，
导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 AllPropType 的可能类型。

#### 1.10.3 never 和 void 的区别

void 可以被赋值为 null 和 undefined 的类型。 never 则是一个不包含值的类型。

拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。

#### 1.11 类型推论

是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性

定义时未赋值就会推论成 any 类型

如果定义的时候就赋值就能利用到类型推论

```typescript
let username2; // 这里会推论成any
username2 = 10;
username2 = "cat";
username2 = null;
```

noImplicitAny
禁止隐式申明 any

```typescript
let a;
console.log(a.b); // 不会隐私申明为any，ts报错，获取b属性可能会获取不到
```

#### 1.12 包装对象（Wrapper Object）

JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。

所有的原始数据类型都没有属性（property）

原始数据类型

布尔值 数值 字符串 null undefined Symbol

```typescript
let name = "cat";
console.log(name.toUpperCase());

console.log(new String("cat").toUpperCase());
```

当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换

```typescript
let isOK1: boolean = true; // 编译通过
let isOK2: boolean = Boolean(1); // 编译通过
let isOK3: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型
```

```typescript
let name1: string = "cat";
console.log(name1.toUpperCase());
let name2: string = new String("cat"); // ts报错
console.log(name2.toUpperCase());
```

#### 1.13 联合类型

联合类型上只能访问两个类型共有的属性和方法

```typescript
function fn(name4: string | number) {
  console.log(name4.toUpperCase()); // 报错 Property 'toUpperCase' does not exist on type 'string | number'.
}
fn();
```

#### 1.14 类型断言

类型断言可以将一个联合类型的变量，指定为一个更加具体的类型

不能将联合类型断言为不存在的类型

```typescript
function fn(name5: string | number) {
  const a = (name5 as number).toFixed(3);
  const b = (name5 as string).length;

  // 不能将联合类型断言为不存在的类型
  const c = name5 as boolean; // 报错Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other.
  console.log(a, b, c);
}

fn();
```

#### 1.15 字符串、数字、布尔值字面量

```typescript
type Lucky = 1 | "One" | true;
let foo: Lucky = "One";
```

#### 1.16 字符串字面量 vs 联合类型

字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种

字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致

#### 2. 函数

#### 2.1 函数的定义

```typescript
function hello(name: string): void {
  console.log("hello", name);
}
hello("Jack");
```

#### 2.2 函数表达式

定义函数类型

```typescript
type GetUsernameFunction = (x: string, y: string) => string;
let getUsername: GetUsernameFunction = function (firstName, lastName) {
  return firstName + lastName;
};
```

#### 2.3 没有返回值

```typescript
let hello2 = function (name: string): void {
  console.log("hello2", name);
};
hello2("Jack");
```

#### 2.4 可选参数

在 TS 中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数

```typescript
function print(name: string, age?: number): void {
  console.log(name, age);
}
print("Jack");
```

#### 2.5 默认参数

```typescript
// 默认参数逻辑上包含可选参数，所以写默认参数的时候没有必要写可选参数的method后面的 ?

// function ajax(url: string, method?: string = "GET") {
function ajax(url: string, method: string = "GET") {
  console.log(url, method);
}
ajax("/users");
```

#### 2.6 剩余参数

```typescript
function sum(...numbers: number[]) {
  return numbers.reduce((val, item) => (val += item), 0);
}
console.log(sum(1, 2, 3));
```

#### 2.7 函数重载

在 Java 中的重载，指的是两个或者两个以上的同名函数，参数不一样
在 TypeScript 中，表现为给同一个函数提供多个函数类型定义

同名函数申明重载中间不能有别的语句隔着

```typescript
let obj: any = {};
function attr(val: string): void;
function attr(val: number): void;
function attr(val: any): void {
  // 这里虽然val:any托底，但是实际语法只是上面的重载，超出上面两种类型会报错
  if (typeof val === "number") {
    obj.age = val;
  } else {
    obj.name = val;
  }
}
attr("Jack");
attr(9);
attr(true); // 会报错
// TS2769: No overload matches this call.
// Overload 1 of 2, '(val: string): void', gave the following error.
// Argument of type 'boolean' is not assignable to parameter of type 'string'.
// Overload 2 of 2, '(val: number): void', gave the following error.
// Argument of type 'boolean' is not assignable to parameter of type 'number'.
// index.tsx(38, 12): The call would have succeeded against this implementation,
// but implementation signatures of overloads are not externally visible.
console.log(obj);
```

用以下泛型方法，可以实现 a 和 b 是活的类型，但是总是相同，不是交叉的效果。如果想要，ab 类型总是交叉不同呢（a 是 string，b 必须是 number，反之亦然）

```typescript
let obj: any = {};
type Person = string | number;
function attr<T extends Person>(a: T, b: T): void {
  // 这里虽然val:any托底，但是实际语法只是上面的重载，超出上面两种类型会报错
  if (typeof a === "string" && typeof b === "number") {
    obj.age = a;
  } else {
    obj.name = b;
  }
}
attr("Jack", "Rose"); // 想要报错，但不报错

attr(9, 7); // 想要报错，但不报错

attr("Jack", 9); // 想要不报错,但报错
```

下面用了联合类型，还差一点，没有实现需求

```typescript
let obj: any = {};
function attr(a: string | number, b: string | number): void {
  // 这里虽然val:any托底，但是实际语法只是上面的重载，超出上面两种类型会报错
  if (typeof a === "string" && typeof b === "number") {
    obj.age = a;
  } else {
    obj.name = b;
  }
}
attr("Jack", "Rose"); // 想要报错，但不报错

attr(9, 7); // 想要报错，但不报错

attr("Jack", 9); // 不报错
```

不用重载比较难实现的例子

```typescript
let obj: any = {};
function attr(a: string, b: number): void;
function attr(a: number, b: string): void;
function attr(a: any, b: any): void {
  // 这里虽然val:any托底，但是实际语法只是上面的重载，超出上面两种类型会报错
  if (typeof a === "string" && typeof b === "number") {
    obj.age = a;
  } else {
    obj.name = b;
  }
}
attr("Jack", "Rose"); // 报错

attr(9, 7); // 报错

attr("Jack", 9); // 不报错

console.log(obj);
```

但是，其实这个需求不用函数重载，用元组加联合类型也能实现

```typescript
let obj: any = {};
function attr(...props: [a: string, b: number] | [a: number, b: string]): void {
  if (typeof props[0] === "string" && typeof props[1] === "number") {
    obj.age = props[0];
  } else {
    obj.name = props[1];
  }
}
attr("Jack", "Rose"); // 报错

attr(9, 7); // 报错

attr("Jack", 9); // 不报错
```

### 3. 类

#### 3.1 如何定义类

```typescript
export {}; // 如果文件中有export会认为是模块，否则下面申明的Person会是全局变量
class Person {
  name: string;
  getName(): void {
    console.log(this.name);
  }
}
let p1 = new Person();
p1.name = "Jack";
p1.getName();
```

编译配置 compilerOption.module = commonjs，编译出结果

```javascript
"use strict";
exports.__esmodule = true;
var Person = /** class **/ function () {
  function Person() {}
  Person.prototype.getName = function () {
    console.log(this.name);
  };
  return Person;
};
var p1 = new Person();
p1.name = "Jack";
p1.getName();
```

#### 3.2 存取器

在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为
构造函数
主要用于初始化类的成员变量属性
类的对象创建时自动调用执行
没有返回值

```typescript
class User {
  myname: string;
  constructor(myname: string) {
    this.myname = myname;
  }
  get name() {
    return this.myname;
  }
  set name(value) {
    this.myname = value;
  }
}

let user = new User("Jack");
user.name = "Rose";
console.log(user.name);
```

#### 3.3 参数属性

```typescript
class User {
  // myName: string; // 有了public mayname: string 可以省去这两句话
  constructor(public myname: string) {
    // this.myName = myName // 有了public mayname: string 可以省去这两句话
  }
  get name() {
    return this.myname;
  }
  set name(value) {
    this.myname = value;
  }
}

let user = new User("Jack");
user.name = "Rose";
console.log(user.name);
```

#### 3.4 readonly

readonly 修饰的变量只能在构造函数中初始化
在 TypeScript 中，const 是常量标志符，其值不能被重新分配
TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly
readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）

```typescript
class Animal {
  public readonly name: string;
  constructor(name) {
    this.name = name;
  }
  changeName(name: string) {
    this.name = name; // 这里报错无法修改
  }
}

let a = new Animal("Jack");
a.changeName("Rose");
```

#### 3.5 实现 implements 关键词

```typescript
// implements关键词+接口，可以用于约束类需要实现的功能--对类的行为进行一些抽象
// 类只能继承一个类，如果想从几个类中拿一些功能，用implements可以实现
interface Radio {
  switchRadio(): void;
}

interface Battery {
  checkBatteryStatus();
}

// implements实现，用了此关键词，class内必须实现Radio接口的内容，此处是switchRadio
class Car implements Radio {
  switchRadio() {}
}

// 可用于提炼出都要实现的功能，至于怎么实现在class中分别定义
class Phone implements Radio {
  switchRadio() {}
}

// 可以约束需要同时实现的多个接口，用逗号隔开
class Cellphone2 implements Radio, Battery {
  switchRadio() {}
  checkBatteryStatus() {}
}

// 接口继承接口之后也能实现上面的需要约束多个接口的需求
interface RadioWithBattery extends Radio {
  checkBatteryStatus();
}

class Cellphone implements RadioWithBattery {
  switchRadio() {}
  checkBatteryStatus() {}
}
```

#### 3.6 类里面的修饰符

```typescript
class Father {
  public name: string; // public关键词修饰，类里面、子类、用类创建对象后的对象都可以访问，外部都可以访问
  protected age: number; // protected关键词修饰，类里面、子类 都可以访问,用类创建对象后的对象，外部其它任何地方不能访问
  private money: number; // private关键词修饰，类里面可以访问，子类和其它任何地方都不可以访问
  constructor(name: string, age: number, money: number) {
    //构造函数
    this.name = name;
    this.age = age;
    this.money = money;
  }
  getName(): string {
    return this.name;
  }
  setName(name: string): void {
    this.name = name;
  }
}
class Child extends Father {
  constructor(name: string, age: number, money: number) {
    super(name, age, money);
  }
  desc() {
    // private属性，子类 不能访问到 money
    console.log(`${this.name} ${this.age} ${this.money}`);
  }
}

let child = new Child("Jack", 10, 1000);
console.log(child.name); // Jack
console.log(child.age); // undefined // protected属性，外部 不能访问到 age
console.log(child.money); // undefined // private属性，外部 不能访问到 money
```

#### 3.7 静态属性 静态方法

```typescript
class Father {
  static className = "Father";
  static getClassName() {
    return Father.className;
  }
  public name: string;
  constructor(name: string) {
    //构造函数
    this.name = name;
  }
}
class Child extends Father {
  constructor(name: string, age: number, money: number) {
    super(name);
  }
  desc() {
    console.log(`${this.name} ${this.age} ${this.money}`);
  }
}
console.log(Father.className);
console.log(Child.className); // 静态属性子类可以继承
console.log(Father.getClassName());
console.log(Child.getClassName()); // 静态方法子类可以继承
```

```typescript
export {};
class Father {
  public name: string;
  constructor(name: string) {
    //构造函数
    this.name = name;
  }
}
class Child extends Father {
  public age: number;

  constructor(name: string, age: number) {
    super(name);
    this.age = age;
  }
  desc() {
    console.log(`${this.name} ${this.age}`);
  }
}
const c1 = new Child("Jack", 18);
```

编译配置 compilerOption.module = commonjs，编译出结果

```javascript
"use strict";
var __extends =
  (this && this.__extends) ||
  (function () {
    var extendStatics = function (c, b) {
      // 拷贝静态属性
      extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (c, b) {
            c.__proto__ = b;
          }) ||
        function (c, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p)) c[p] = b[p];
        };
      return extendStatics(c, b);
    };
    return function (c, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError(
          "Class extends value " + String(b) + " is not a constructor or null"
        );
      extendStatics(c, b);
      function __() {
        this.constructor = c;
      }
      c.prototype =
        b === null
          ? Object.create(b)
          : ((__.prototype = b.prototype), new __()); // 逗号语法返回值是最后一句话的值
    };
  })();
exports.__esModule = true;
var Father = /** @class */ (function () {
  function Father() {}
  return Father;
})();
var Child = /** @class */ (function (_super) {
  __extends(Child, _super); // 继承静态属性
  function Child() {
    return (_super !== null && _super.apply(this, arguments)) || this;
  }
  return Child;
})(Father);
```

#### 3.8 js 原生继承 extends 关键词在 ts 下的使用

子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性
将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑
super 可以调用父类上的方法和属性

```typescript
class Person {
  name: string; //定义实例的属性，默认省略 public 修饰符
  age: number;
  constructor(name: string, age: number) {
    //构造函数
    this.name = name;
    this.age = age;
  }
  getName(): string {
    return this.name;
  }
  setName(name: string): void {
    this.name = name;
  }
}
class Student extends Person {
  no: number;
  constructor(name: string, age: number, no: number) {
    super(name, age);
    this.no = no;
  }
  getNo(): number {
    return this.no;
  }

  // 重写父类方法
  getName(): string {
    // super. 调用父类方法
    return "child" + super.getName();
  }
}
let s1 = new Student("Jack", 10, 1);
console.log(s1);
```

#### 3.9 抽象类

抽象描述一种抽象的概念，无法被实例化，只能被继承
无法创建抽象类的实例
抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现

```typescript
// 抽象类
abstract class Animal3 {
  name: string;

  // 抽象方法
  abstract speak();
}
class Cat extends Animal3 {
  speak() {
    console.log("喵喵喵");
  }
}
let cat = new Cat();
cat.speak();
```

```typescript
type O = {
  name: string;
};
interface E extends O {
  // 扩展接口
  age: number;
}
const a: E = {
  name: "Jack",
  age: 18,
};
```

```typescript
// 必须包含name,其他类型随意都可以
interface T {
  name: string;
  [key: string]: any; // 其他类型随意都可以，这里的key 可以不写做key，比如key1，xxx
}
```

```typescript
let a: number = 1
a as any as string = 'a' // 不合理的断言会报错，双重断言可以解决
```

### 别名 关键词 type

```typescript
// 别名 声明一个类型
type Sum = ((aa: number, bb: number) => number) | string;

// 接口 定义函数是冒号隔开函数返回值，不是箭头
interface Sum {
  (a: number, b: number): number;
}
interface Sum {
  (a: number, b: number): number | string; // 这样写法是错误的，赋值string会报错，接口无法写又是函数又是string，别名可以用联合类型
}
// 区别 interface 可以继承  可以被类来实现
// type仅仅是一个别名 一般在定义联合类型 ，定义临时变量时可以使用
let sum2: Sum = (a: number, b: number): number => a + b;
```

### 泛型 generics

```typescript
// <T> 申明泛型T
// 泛型 , 用来在代码执行时传入的类型，来确定结果
function createArray<T>(len: number, value: T): T[] {
  let result = [];
  for (let i = 0; i < len; i++) {
    result.push(value);
  }
  return result;
}
let arr = createArray(3, "HELLO");

// 多个泛型  元组的交换 [boolean,number] = [number,boolean]
const swap = <T, K>(tuple: [T, K]): [K, T] => {
  return [tuple[1], tuple[0]];
};
swap<number, number>([1, 2]); // 不报错
swap<string, number>(["string", 2]); // 不报错
swap([1, 2]); // 不报错，灵活的泛型，根据使用时的类型推断函数内的类型
export {};
```

### 用 ts 的 extends 约束泛型

约束必须带 length 属性

```typescript
interface IWithLength {
  length: number;
}

// 用extends 约束泛型必须含有length属性，
// 函数中使用泛型
function echoWithLength<T extends IWithLength>(arg: T): T {
  // 这样就不会ts报没有length的错了
  console.log(arg.length);
  return arg;
}

const str = echoWithLength("str");
const obj = echoWithLength({ length: 10, width: 10 });
const arr2 = echoWithLength([1, 2, 3]);
```

#### 用在类中使用泛型约束

```typescript
class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item);
  }
  pop(): T {
    return this.data.shift();
  }
}

// 约束前
const queue = new Queue();
queue.push(1);
queue.push("str");

// new出来的的对象中可能推入任何值，如手动设定成any或者允许自动定义any类型，使用方法，在运行中会产生ts检查不到
console.log(queue.pop().toFixed()); // 手动或自动设为any，能消除ts报错，但运行时会产生错误
console.log(queue.pop().length);

/*
class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}*/

const queue2 = new Queue<number>();
queue2.push(1);
console.log(queue2.pop().toFixed()); // 使用数字有字符串没有的toFixed
// console.log(queue2.pop().length) // ts报错，没有length，能很好约束。保证在ts不报错的情况下，运行也不报错

const queue3 = new Queue<string>();
queue3.push("str");
console.log(queue3.pop().length); // 使用字符串有数字没有的length
// console.log(queue2.pop().toFixed()) // ts报错，没有toFixed，能很好约束。保证在ts不报错的情况下，运行也不报错
```

#### 用在 interface 中使用泛型约束

```typescript
interface KeyPair<T, U> {
  key: T;
  value: U;
}

// 使用的时候灵活地传入使用时需要的泛型
let kp1: KeyPair<number, string> = { key: 123, value: "str" };
let kp2: KeyPair<string, number> = { key: "test", value: 123 };

let arr: number[] = [1, 2, 3];
let arrTwo: Array<number> = [1, 2, 3];
```

#### 在函数中使用泛型约束

```typescript
// 未用泛型时,函数定义适用局限性大
interface IPlusOrg {
(a: number, b: number) : number
}

// 圆括号中的是入参,冒号后的是返回值
interface IPlus<T> {
(a: T, b: T) : T
}
function plus(a: number, b: number): number {
return a + b;
}
function connect(a: string, b: string): string {
return a + b
}

// 函数定义加入了泛型更灵活,一个IPlus接口可以满足以下两个函数的需求
const a: IPlus<number> = plus
const b: IPlus<string> = connect
```
