这一页千万别特格式化，会引起mdx标签对齐的bug,导致编译失败


```html
import Leekcode1928 from "./leekcode1928.tsx";

<div>
    <Leekcode928/>
去掉 html注释，使用Leekcode1928组件，看console.log，解题内容在组件中
</div>
```

### 1928. 规定时间内到达终点的最小花费(难)

<p>一个国家有 <code>n</code>&nbsp;个城市，城市编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，题目保证 <strong>所有城市</strong>&nbsp;都由双向道路 <b>连接在一起</b>&nbsp;。道路由二维整数数组&nbsp;<code>edges</code>&nbsp;表示，其中&nbsp;<code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;之间有一条双向道路，耗费时间为&nbsp;<code>time<sub>i</sub></code>&nbsp;分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>

<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>passingFees</code>&nbsp;表示，其中&nbsp;<code>passingFees[j]</code>&nbsp;是你经过城市 <code>j</code>&nbsp;需要支付的费用。</p>

<p>一开始，你在城市&nbsp;<code>0</code>&nbsp;，你想要在 <code>maxTime</code>&nbsp;<strong>分钟以内</strong>&nbsp;（包含 <code>maxTime</code>&nbsp;分钟）到达城市&nbsp;<code>n - 1</code>&nbsp;。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong>&nbsp;（<strong>包括</strong>&nbsp;起点和终点城市的通行费）。</p>

<p>给你&nbsp;<code>maxTime</code>，<code>edges</code>&nbsp;和&nbsp;<code>passingFees</code>&nbsp;，请你返回完成旅行的&nbsp;<strong>最小费用</strong>&nbsp;，如果无法在&nbsp;<code>maxTime</code>&nbsp;分钟以内完成旅行，请你返回&nbsp;<code>-1</code>&nbsp;。</p>


示例 1：

import imgSrc1 from "./images/1928_1.png";

<img src={imgSrc1}  />

<pre><b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<br/><b>输出：</b>11
<br/><b>解释：</b>最优路径为 0 -&gt; 1 -&gt; 2 -&gt; 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。
</pre>

示例 2：

import imgSrc2 from "./images/1928_2.png";

<img src={imgSrc2}  />

<pre><b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<br/><b>输出：</b>48
<br/><b>解释：</b>最优路径为 0 -&gt; 3 -&gt; 4 -&gt; 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。
<br/>你不能选择路径 0 -&gt; 1 -&gt; 2 -&gt; 5 ，因为这条路径耗费的时间太长。
</pre>


示例 3：

<pre><b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<br/><b>输出：</b>-1
<br/><b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。
</pre>

提示：

1 <= maxTime <= 1000

n == passingFees.length

2 <= n <= 1000

n - 1 <= edges.length <= 1000

<code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code>

<code>1 &lt;= time<sub>i</sub> &lt;= 1000</code>

1 <= passingFees[j] <= 1000

图中两个节点之间可能有多条路径。

图中不含有自环。




### 2618.检查是否是类的对象实例（中）
```html
import Leekcode2618 from "./leekcode2618.tsx";

<div>
    <Leekcode2618/>
    去掉 html注释，使用Leekcode1928组件，看console.log，解题内容在组件中

</div>
```

<div>
<div className="elfjS" data-track-load="description_content"><p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>

<p>可以传递给函数的数据类型没有限制。例如，值或类可能是&nbsp; <code>undefined</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>func = () =&gt; checkIfInstance(new Date(), Date)
<br/><b>输出：</b>true
<br/><strong>解释：</strong>根据定义，Date 构造函数返回的对象是 Date 的一个实例。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>{'func = () =&gt; { class Animal {}; class Dog extends Animal {}; return checkIfInstance(new Dog(), Animal); }'}
    <br/><b>输出：</b>true
<br/><strong>解释：</strong>
class Animal {'{}'};
class Dog extends Animal {'{}'};
checkIfInstanceOf(new Dog(), Animal); // true

Dog 是 Animal 的子类。因此，Dog 对象同时是 Dog 和 Animal 的实例。</pre>

<p><strong>示例 3：</strong></p>

<pre><b>输入：</b>func = () =&gt; checkIfInstance(Date, Date)
<br/><b>输出：</b>false
<br/><strong>解释：</strong>日期的构造函数在逻辑上不能是其自身的实例。
</pre>

<p><strong>示例 4：</strong></p>

<pre><b>输入：</b>func = () =&gt; checkIfInstance(5, Number)
<br/><b>输出：</b>true
<br/><strong>解释：</strong>5 是一个 Number。注意，"instanceof" 关键字将返回 false。</pre>
</div>
</div>




### 2619.数组原型对象的最后一个元素（简）
```html
import Leekcode2619 from "./leekcode2619.tsx";

<div>
    <Leekcode2619/>
    去掉 html注释，使用Leekcode2619组件，看console.log，解题内容在组件中
</div>
```

<div>
<div className="elfjS" data-track-load="description_content"><p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回&nbsp;<code>-1</code>&nbsp;。</p>

<p>你可以假设数组是 <code>JSON.parse</code> 的输出结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1 ：</strong></p>

<pre><b>输入：</b>nums = [null, {}, 3]
<br/> <b>输出：</b>3<b>解释</b>：调用nums.last()后返回最后一个元素： 3。</pre>
<p><strong>示例 2 ：</strong></p>

<pre><b>输入：</b>nums = []<b>输出：</b>-1<strong>解释：</strong>因为此数组没有元素，所以应该返回 -1。</pre>

<p>&nbsp;</p>

<p><b>提示：</b></p>

<ul>
    <li><code>arr</code> 是一个有效的 JSON 数组</li>
    <li><code>0 &lt;= arr.length &lt;= 1000</code></li>
</ul>
</div>

</div>


### 2620. 计数器（简）

```html
import Leekcode2620 from "./leekcode2620.tsx";
<div>
<Leekcode2620/>
去掉 html注释，使用Leekcode2620组件，看console.log，解题内容在组件中
</div>
```

<div className="elfjS" data-track-load="description_content"><p>给定一个整型参数 <code>n</code>，请你编写并返回一个 <code>counter</code><strong>&nbsp;</strong>函数。这个&nbsp;<code>counter</code><strong>&nbsp;</strong>函数最初返回 <code>n</code>，每次调用它时会返回前一个值加 1 的值 ( <code>n</code> ,&nbsp; <code>n + 1</code> ,&nbsp; <code>n + 2</code> ，等等)。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>
n = 10
["call","call","call"]
<br/><strong>输出：</strong>[10,11,12]
<br/><strong>解释：</strong>
<br/>counter() = 10 // 第一次调用 counter()，返回 n。
<br/>counter() = 11 // 返回上次调用的值加 1。
<br/>counter() = 12 // 返回上次调用的值加 1。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>
<br/>n = -2
<br/>["call","call","call","call","call"]
<br/><strong>输出：</strong>[-2,-1,0,1,2]
<br/><strong>解释：</strong>counter() 最初返回 -2。然后在每个后续调用后增加 1。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
<li><code>-1000<sup>&nbsp;</sup>&lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= calls.length &lt;= 1000</code></li>
<li><code>calls[i] === "call"</code></li>
</ul>
</div>

### 2621.睡眠函数（简）
```html
import Leekcode2621 from "./leekcode2621.tsx";

<div>
<Leekcode2621/>
去掉 html注释，使用Leekcode2620组件，看console.log，解题内容在组件中
</div>
```

<div className="elfjS" data-track-load="description_content"><p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code>&nbsp;，并休眠 <code>millis</code> 毫秒。要求此函数可以解析任何值。</p>

<p>&nbsp;</p>

<p><b>示例 1：</b></p>

<pre><b>输入：</b>millis = 100
<b>输出：</b>100
<b>解释：</b>
在 100ms 后此异步函数执行完时返回一个 Promise 对象
let t = Date.now();
sleep(100).then(() =&gt; {`{
console.log(Date.now() - t); // 100
}`});
</pre>

<p><b>示例 2：</b></p>

<pre><b>输入：</b>millis = 200
<b>输出：</b>200
<b>解释：</b>在 200ms 后函数执行完时返回一个 Promise 对象
</pre>

<p>&nbsp;</p>

<p><b>提示：</b></p>

<ul>
<li><code>1 &lt;= millis &lt;= 1000</code></li>
</ul>
</div>

### 2622.有时间限制的缓存（中）
```html
import Leekcode2622 from "./leekcode2622.tsx";

<div>
    <Leekcode2622/>
    去掉 html注释，使用Leekcode2620组件，看console.log，解题内容在组件中
</div>
```

<div><div className="elfjS" data-track-load="description_content"><p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>

<p>该类有三个公共方法：</p>

<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>

<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>

<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
timeDeays = [0, 0, 50, 50, 150]
<strong>输出：</strong> [null, false, 42, 1, -1]
<strong>解释：</strong>
在 t=0 时，缓存被构造。
在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。
在 t=50 时，请求 key=1 并返回值 42。
在 t=50 时，调用 count() ，缓存中有一个未过期的键。
在 t=100 时，key=1 到期。
在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
timeDelays = [0, 0, 40, 50, 120, 200, 250]
<strong>输出：</strong> [null, false, true, 50, 50, -1]
<strong>解释：</strong>
在 t=0 时，缓存被构造。
在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。
当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。
在 t=50 时，调用 get(1) ，返回 50。
在 t=120 时，调用 get(1) ，返回 50。
在 t=140 时，key=1 过期。
在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。
在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
<li><code>0 &lt;= key, value &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= duration &lt;= 1000</code></li>
<li><code>1 &lt;= actions.length &lt;= 100</code></li>
<li><code>actions.length === values.length</code></li>
<li><code>actions.length === timeDelays.length</code></li>
<li><code>0 &lt;= timeDelays[i] &lt;= 1450</code></li>
<li><code>actions[i]</code> 是 "TimeLimitedCache"、"set"、"get" 和 "count" 中的一个。</li>
<li>第一个操作始终是 "TimeLimitedCache" 而且一定会以 0 毫秒的延迟立即执行</li>
</ul>
</div></div>


### 2623.记忆函数（中）

import Leekcode2623 from "./leekcode2623.tsx";

<div>
    <Leekcode2623/>
    去掉 html注释，使用Leekcode2623组件，看console.log，解题内容在组件中
</div>


<div className="elfjS" data-track-load="description_content"><p>请你编写一个函数 <code>fn</code>，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>

<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>

<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>

<ul>
<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。假设如果参数 <code>(b, a)</code> 已经缓存了值，其中 <code>a != b</code>，它不能用于参数 <code>(a, b)</code>。例如，如果参数是 <code>(3, 2)</code> 和 <code>(2, 3)</code>，则应进行两个单独的调用。</li>
<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>
<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>
fnName = "sum"
actions = ["call","call","getCallCount","call","getCallCount"]
values = [[2,2],[2,2],[],[1,2],[]]
<strong>输出：</strong>[4,4,1,3,2]
<strong>解释：</strong>
const sum = (a, b) =&gt; a + b;
const memoizedSum = memoize(sum);
memoizedSum (2, 2);// "call" - 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。
memoizedSum (2, 2);// "call" - 返回 4。没有调用 sum()，因为前面有相同的输入。
// "getCallCount" - 总调用数： 1
memoizedSum(1, 2);// "call" - 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。
// "getCallCount" - 总调用数： 2
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：
</strong>fnName = "factorial"
actions = ["call","call","call","getCallCount","call","getCallCount"]
values = [[2],[3],[2],[],[3],[]]
<strong>输出：</strong>[2,6,2,2,6,2]
<strong>解释：</strong>
const factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));
const memoFactorial = memoize(factorial);
memoFactorial(2); // "call" - 返回 2。
memoFactorial(3); // "call" - 返回 6。
memoFactorial(2); // "call" - 返回 2。 没有调用 factorial()，因为前面有相同的输入。
// "getCallCount" -  总调用数：2
memoFactorial(3); // "call" - 返回 6。 没有调用 factorial()，因为前面有相同的输入。
// "getCallCount" -  总调用数：2
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：
</strong>fnName = "fib"
actions = ["call","getCallCount"]
values = [[5],[]]
<strong>输出：</strong>[8,1]
<strong>解释：
</strong>fib(5) = 8 // "call"
// "getCallCount" -&nbsp;总调用数：1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>actions.length === values.length</code></li>
<li><code>actions[i]</code> 为&nbsp;"call" 和 "getCallCount" 中的一个</li>
<li><code>fnName </code>为 "sum", "factorial" 和 "fib" 中的一个</li>
</ul>
</div>