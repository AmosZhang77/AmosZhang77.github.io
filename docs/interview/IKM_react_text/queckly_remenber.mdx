
#### 1

Which of the following changes to the JavaScript code below will result in "Jane Doe has a staff of 5" being displayed (line numbers are for reference purposes only)?

```typescript
class Employee {
  constructor(fn, ln) {
    this.fn = fn; // 3
    this.ln = ln; // 4
  }
  getFullName() {
    // 7
    return this.fn + " " + this.ln; // 8
  } // 9
}

class Manager extends Employee {
  constructor(fn, ln, staff) {
    // 13
    this.staff = staff;
  }
  displayInfo() {
    console.log(this.getFullName() + " has a staff of " + this.staff);
  }
}
var mgr = new Manager("Jane", "Doe", 5);
mgr.displayInfo();
```

A.
Add after Line 13:

```typescript
super(fn, ln);
```

B.
Replace Lines 3 and 4 with:

```
set fullName(fn,ln){
  this.fn = fn;
  this.ln = ln;
}
```

C.
Replace Lines 7-9 with:

```typescript
get FullName(){
return this.fn + " " + this.ln;
}
```

D.
Add aner Line 13:

```typescript
this.fn = fn;
this.ln = ln;
```

E.
Replace lines 3 and 4 with:

```typescript
var fname = fn;
var lname = ln;
return fname + " " + lname;
```

A D

以下对 JavaScript 代码（行号仅供参考）的哪些更改将导致显示“Jane Doe has a staff of 5”？

#### 2

Which of the following statements correctly describe cross-site scripting (XSS) attacks?

A. XSS attacks occur when a malicious payload is sent to the web server from a web page,
and is used to attack the web server itself.

B. XSS refers to an HTTP response headers vulnerability that lets malicious JavaScript obtain a user's sessionStorage data and impersonate that user.

C. Modern browsers protect users from many XSS attacks by automatically removing any '<'script'>' tags from HTTP request payloads.

D. Websites are vulnerable to XSS attacks if they do not do sufficient validation or encoding of user-entered data.

E. XSS is a client-side exploit which allows an attacker to inject and execute malicious client-side JavaScript code in another user's browser.

D E

以下哪些陈述正确地描述了跨站脚本（XSS）攻击？

A. XSS 攻击发生在恶意负载从网页发送到 web 服务器时，并被用来攻击 web 服务器本身。

B. XSS 是指 HTTP 响应头中的一个漏洞，它允许恶意 JavaScript 获取用户的 sessionStorage 数据并冒充该用户。

C. 现代浏览器通过自动从 HTTP 请求负载中移除任何 '<'script'>' 标签来保护用户免受许多 XSS 攻击。

D. 如果网站没有充分验证或编码用户输入的数据，则它们容易受到 XSS 攻击。

E. XSS 是一种客户端漏洞利用技术，它允许攻击者在其他用户的浏览器中注入并执行恶意的客户端 JavaScript 代码。

malicious [məˈlɪʃəs] 恶意的

payload [ˈpeɪloʊd] 有效载荷，有酬负载;装备

vulnerability [ˌvʌlnərə'bɪləti] 脆弱性;弱点;易伤性;可捕性;

impersonate [ɪmˈpɜːrsəneɪt] 模仿;冒充，假冒，假扮;扮演，饰演;使人格化

解释：

A. 错误。XSS 攻击并不是直接攻击 web 服务器本身，而是攻击者利用 web 应用的安全漏洞，将恶意脚本注入到 web 页面中，当用户浏览这些页面时，恶意脚本会在用户的浏览器中执行，从而盗取用户信息、进行钓鱼攻击等。攻击者并不直接向 web 服务器发送恶意负载来攻击服务器。

B. 错误。XSS 并不是指 HTTP 响应头中的漏洞，而是指攻击者通过注入恶意脚本到 web 页面中，这些脚本可以在用户的浏览器中执行，从而可能访问或修改用户的 sessionStorage 数据等。此外，XSS 攻击并不限于 JavaScript，它可以通过任何形式的客户端脚本（如 VBScript）来执行。

C. 错误。现代浏览器确实提供了一些防护措施来减少 XSS 攻击的风险，但它们并不总是能自动移除 HTTP 请求负载中的所有 '<'script'>' 标签。XSS 防护通常需要综合的方法，包括服务器端的数据验证和编码、使用合适的内容安全策略（CSP）等。

D. 正确。如果网站没有充分验证或编码用户输入的数据，那么这些未经验证或未编码的数据可能会被直接嵌入到 web 页面中，从而允许攻击者注入恶意脚本。这是 XSS 攻击的一个常见漏洞点。

E. 正确。XSS 是一种客户端攻击技术，它允许攻击者在其他用户的浏览器中注入并执行恶意的客户端 JavaScript 代码。这种攻击可以窃取用户的敏感信息、进行钓鱼攻击、篡改网页内容等。

#### 3

Which of the following statements are correct regarding the use of keys within object collections of React,js components?

A. They invoke warnings within a browser console ("Warning: Each child in an array or iterator should have a unique "key
prop...").

B. They are used to maintain state between components.

C. Number data types are only used as collection key values and must be only Base32

D. They can be used as an index to quickly sort or query collections!

E. They help identify which items have changed and are added/removed. This helps to ensure that the React.js component UI
maintains stability.

A E

关于在 React.js 组件的对象集合中使用键（keys）的以下哪些陈述是正确的？

A. 它们在浏览器控制台中引发警告（“警告：数组或迭代器中的每个子元素都应该有唯一的 key 属性...”）。

B. 它们用于在组件之间维持状态。

C. 数字数据类型仅用作集合键值，并且必须是 Base32。

D. 它们可以用作索引来快速排序或查询集合！

E. 它们有助于识别哪些项目已更改以及是否已添加/删除。这有助于确保 React.js 组件 UI 的稳定性。

解释：
D key 并不是用来直接排序或查询集合的索引

A. 正确。在 React 中，当在组件的数组或迭代器子元素中未使用或错误使用 key 属性时，浏览器控制台会发出警告。这是因为 React 使用 key 来跟踪列表中每个元素的身份，从而优化渲染过程。如果没有提供唯一的 key，React 将难以高效地更新和渲染组件，并可能发出关于缺少 key 的警告。

B. 错误。key 属性并不是用来在组件之间维持状态的。组件的状态通常是通过组件内部的状态（state）或属性（props）来管理的。key 主要是帮助 React 识别哪些项是唯一的，以便在 DOM 更新时可以进行有效的重新渲染。

C. 错误。在 React 中，key 可以是任何数据类型，包括但不限于字符串、数字或短字符串形式的唯一标识符。并没有规定 key 必须是 Base32 编码的数字数据类型。实际上，在大多数情况下，使用字符串作为 key 是更常见的做法，因为它们可以提供更多的上下文信息。

D. 错误。虽然 key 可以帮助 React 跟踪列表中的元素，但它们并不是用来直接排序或查询集合的索引。排序和查询通常是在将数据传递给 React 组件之前，在 JavaScript 中完成的。key 主要用于帮助 React 识别列表中的哪些元素已经改变、添加或删除，以便它可以高效地更新 DOM。

E. 正确。key 帮助 React 识别哪些列表项已经改变、添加或删除，这是通过比较前后两个列表中的 key 值来实现的。这样做可以确保 React 只更新那些真正发生变化的元素，而不是重新渲染整个列表，从而提高了性能并保持了组件 UI 的稳定性。

#### 4

Which of the following React js lifecycle events are used to perform initialization of components or when operations are not needed any longer?

A. The componentDidCatch event which is invoked when an unhandled error occurs and performs extended logging

B. The componentWillUnMount event which is used for cleanup

C. The UNSAFE_componentWillMount event which is triggered after a server renders

D. The render event which is invoked after the componentDidMount event

E. A constructor event which is initialized in the creation of the component

B E

以下哪些 React js 生命周期事件用于执行组件的初始化或在操作不再需要时执行？

A. 当发生未处理的错误并执行扩展日志记录时调用的 componentDidCatch 事件

B. 用于清理的 componentWillUnmount 事件

C. 在服务器渲染后触发的 UNSAFE_componentWillMount 事件

D. 在 componentDidMount 事件后调用 render 事件（注意：render 不是事件）

E. 在组件创建时初始化的 constructor 事件

event is invoked

invoked [ɪnˈvoʊkt] 调用 援引，援用(法律、规则等作为行动理由);提及，援引(某人、某理论、实例等作为支持);提出

triggered [ˈtrɪɡərd] 触发

解释：

在 React 的组件生命周期中，有些方法用于组件的初始化，而有些则用于执行清理工作或在组件不再需要时执行操作。

A. 错误。componentDidCatch 生命周期方法并不是用于初始化组件或在不需要操作时执行的。它是用来捕获子组件树中 JavaScript 错误的方法，并允许你记录这些错误，或者展示一个降级 UI 给用户。

B. 正确。componentWillUnmount 生命周期方法是用来执行清理工作的，比如取消网络请求、移除事件监听器等。这是在组件不再需要时执行的，符合题目要求。

C. 错误。UNSAFE_componentWillMount 是一个即将被废弃的生命周期方法，它在组件即将挂载到 DOM 之前被调用。尽管它在某种程度上与初始化相关，但由于其不安全性（可能导致不必要的渲染），React 推荐避免使用它，并且在未来的版本中可能会被移除。此外，它并不符合“当操作不再需要时执行”的描述。

D. 错误。render 方法并不是生命周期方法，而是一个组件应该总是定义的方法，用于输出组件的 React 元素。它通常在 componentDidMount（或更现代的 useEffect 钩子，对于函数组件）之后被调用，但这不是用来表示“初始化”或“不再需要时执行”的。

E. 正确。构造函数（constructor）是类组件的初始化方法，它在组件被创建时调用。在这里，你可以初始化状态（state）或绑定事件处理函数等。这符合题目中“用于执行组件的初始化”的描述。

#### 5

Which of the following statements are correct regarding the use of stateless components within React.js?

A. They allow for state values to more easily be transferred to child properties and can be easier to troubleshoot.

B. They can be used to create the initial structure of higher-level React.js components.

C. The reserved word "this" is not required, which can contribute to better understanding of the component logic and reduces potential issues related to a misplacement of the keyword.

D. They are not required to return JSX.

E. Classes are not needed, which removes overhead and extra un-needed code and is easier to test.

B C E

关于在 React.js 中使用无状态组件的以下哪些说法是正确的？

A. 它们允许状态值更容易地转移到子属性中，并可能更容易进行故障排除。

B. 它们可用于创建更高层次 React.js 组件的初始结构。

C. 不需要保留字“this”，这有助于更好地理解组件逻辑，并减少了与关键字位置不当相关的潜在问题。

D. 它们不需要返回 JSX。

E. 不需要类，这消除了开销和多余的代码，并且更容易测试。

解释：

A. 错误。无状态组件（Stateless Components）本身不持有状态（state），因此它们不能直接将状态值转移到子属性中。它们通过接收 props 来接收数据，并将这些数据传递给子组件，但这并不意味着它们“更容易”转移状态值。此外，无状态组件的易调试性更多取决于组件的设计和实现方式，而非它们是否是无状态的。

B. 正确。无状态组件通常用于构建更高层次 React.js 组件的初始结构。由于它们不包含状态或生命周期方法，它们非常适合作为 UI 的静态部分，或者作为更高层次组件中的可重用部分。

C. 正确。在无状态组件中，不需要使用保留字"this"，因为无状态组件是纯粹的函数，它们不依赖于组件实例。这有助于更好地理解组件逻辑，并减少了因关键字使用不当而导致的潜在问题。

D. 错误。虽然无状态组件不一定非要返回 JSX，但通常它们的用途就是渲染 JSX。如果不返回 JSX，那么它们的使用场景就变得非常有限，且通常不会被用作 React 组件。

E. 正确。使用无状态组件意味着不需要类（Classes），这减少了代码的开销和不必要的复杂性。无状态组件通常更简洁、更易于理解和测试，因为它们是纯函数，没有副作用。

#### 6

A developer is updating a React.js restaurant reservations application to occur on the restaurant administration side and provide up-to date information on who has requested a reservation for the day,
However, null data is allowed into the application's data source which sometimes causes issues with showing the entire list of reservations.
A quick fix is needed without having to alter server-side code or the database.
Based on the code snippet below, which of the following additional validation steps can be applied to ensure the incoming reservations list is not empty and will not show the component if it is not available?

```tsx
<div>
  {props.reservations.length && (
    <ReservationList messages={props.reservations} />
  )}
</div>
```

A. Convert the React.js variable to a string which will automatically parse out undefined variables:

```tsx
<div>{string(ReservationList)}</div>
```

B. Before being passed into the component, use PropTypes to ensure at least one element is returned:

```tsx
ReservationList.propTypes(children: PropTypes.element.isRequired );
```

C. Check the reservations list for length at runtime and will not display the component if the list has a length of 0 (zero):

```tsx
<div>
  {props.reservations.length > 0 && (
    <ReservationList messages={props.reservations} />
  )}
</div>
```

D. Check the incoming props for length before being added to the returned JSX within ReservationList:

```tsx
const ReservationList = (props) => {
  const reservations = props.list > 0 ? [] : props.list;
  return (
    <ul>
      {reservations.map((message) => (
        <Item key={message} message={message} />
      ))}
    </ul>
  );
};
```

E.
The ReservationList object should contain a defaultProps type to ensure the array has a basic value!

```tsx
class ReservationList extends React.Component{
}
static defaultProps = {
reservations:[]
}
render(){
return (<div>{reservations}</div>)
}
```

C

以下哪些陈述描述了以下 TypeScript 代码片段中联合类型的使用？

A. 将 React.js 变量转换为字符串，这将自动解析出未定义的变量：

B. 在传递给组件之前，使用 PropTypes 来确保至少返回一个元素：

C. 在运行时检查预订列表的长度，如果列表长度为 0（零），则不显示组件：

D. 在将传入的属性添加到 ReservationList 返回的 JSX 之前，检查其长度：

E. ReservationList 对象应包含 defaultProps 类型，以确保数组具有基本值！

reservations [ˌrɛzərˈveɪʃənz] 预订

解释：
这个问题是关于在 React 中处理组件渲染的条件，特别是在给定的数据源可能包含空数据或 null 值的情况下。目标是确保当没有可用的预订列表时，ReservationList 组件不会被渲染。

A. 这个选项试图将 React 组件或变量转换为字符串，这是不正确的，因为 string(ReservationList)并不是有效的 React 或 TypeScript 语法，且无法用来处理数组长度或未定义值的问题。

B. 这个选项提到使用 PropTypes 来确保至少有一个元素被返回，但 PropTypes 通常用于类型检查，而不是用于确保数组非空。此外，给出的代码片段语法错误（children: PropTypes.element.isRequired 应该包含在 ReservationList.propTypes = {...}中），且它并不直接解决数组为空的问题。

C. 这个选项正确地检查了 props.reservations 数组的长度，并仅在长度大于 0 时才渲染 ReservationList 组件。这是解决这个问题的直接且有效的方法。

D. 这个选项尝试在 ReservationList 组件内部检查传入的属性长度，但方法有误。props.list > 0 ? [] : props.list; 这行代码实际上在 props.list 长度大于 0 时返回了一个空数组，这会导致组件总是显示一个空的列表（如果其他部分的代码允许的话），而不是不渲染组件。

E. 这个选项提出了使用 defaultProps 来确保数组有一个基础值（在这个情况下是一个空数组）。然而，这并不会阻止组件在数组为空时被渲染；它只是提供了一个默认值，而问题要求的是在数组为空时不渲染组件。

#### 7

A bus routing application uses Reactjs. The schedule data should be shown when the user selects a bus schedule.
However, no data is displayed in the app view. Based on the code below, which of the following correctly describe how this issue can be resolved?

```tsx
import { Switch, Route } from "react-router-dom";
const Main = () => (
  <main>
    <Switch>
      <Route exact path="/" component={Home} />
      <Route path="/buses" component={Buses} />
      <Route path="/schedules" component={Schedules} />
    </Switch>
  </main>
);
```

A. Edit the schedules route by adding a parameter:

```tsx
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/buses" component={Buses} />
  <Route path="/schedules/:number" component={Schedules} />
</Switch>
```

B. Remove the Buses route because only schedules are required

```tsx
<Switch>
<Route exact path=’/’ component = {Home}/>
<Route path = '/schedules' component={Schedules}/>
</Switch>
```

C. Edit the Buses and schedules routes by adding a parameter

```tsx
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/buses/:number" component={Buses} />
  <Route path="/schedules/:number" component={Schedules} />
</Switch>
```

D. Add a bus segment onto the Buses route

```tsx
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/buses/bus/:number" component={Buses} />
  <Route path="/schedules" component={Schedules} />
</Switch>
```

E. Edit the buses route by adding a parameter:

```tsx
<Switch>
<Route exact path='/' component={Home}/>
<Route path='/buses/:number' component={Buses}/
<Route path='/schedules' component={Schedules}/>
</Switch>
```

A

一个使用 Reactjs 的公交路线应用程序。当用户选择公交时间表时，应显示时间表数据。但是，应用程序视图中没有显示任何数据。基于以下代码，以下哪些选项正确地描述了如何解决此问题？

A. 通过在路由中添加参数来修改时间表路由

B. 移除公交路线，因为只需要时间表

C. 通过在路由中添加参数来同时修改公交和时间表路由

D. 在公交路线上添加一个包含公交编号的段

E. 通过在路由中添加参数来修改公交路线

segment [ˈseɡmənt , seɡˈment] 段;部分;片;弓形;

#### 8

Which of the following are valid calls to function calc1, given the JavaScript code snippet below?

```tsx
let calc2 = (z) => z * 10;
let calc1 = (x, y) => {
  return x * y + calc2(x);
};
```

A. let values =[2,3];
calc1.apply(values);

B. calc1.call(this,2,3);

C. calc1(2,3);

D. calc1.ca11(2,3);

E. let values =[2,3];
calc1.apply(this,values);

B C E

给定下面的 JavaScript 代码片段，哪些是对函数 calc1 的有效调用？

#### 8

Which of the following correctly describe what a template literal can be used for in JavaScript code?

A. Use single quotes to perform HTML escaping.

B. Use double quotes to form multiple line strings

C. Add any functionality to strings.

D. Make strings that can span multiple lines and substitute part of the string for the values of variables or expressions (also called
string interpolation).

E. Transform a string so it is safe to include in HTML (also called HTML escaping)

D

以下哪些选项正确地描述了模板字面量在 JavaScript 代码中可以用作什么？

A. 使用单引号来执行 HTML 转义。

B. 使用双引号来形成多行字符串。

C. 向字符串添加任何功能。

D. 创建可以跨越多行的字符串，并将字符串的一部分替换为变量或表达式的值（也称为字符串插值）。

E. 转换字符串，使其可以安全地包含在 HTML 中（也称为 HTML 转义）。

解释：

A. 错误。模板字面量（Template Literals）使用反引号 (`) 而不是单引号 (') 来包含字符串，它们本身并不直接执行 HTML 转义。HTML 转义通常是通过在字符串中插入特定的转义字符（如 &lt; 代替 <）来实现的，或者通过模板字符串中的表达式调用如 text.replace(/'<'/g, '&lt;') 这样的函数来实现。

B. 错误。虽然模板字面量可以很方便地用来创建多行字符串（因为你可以直接在字符串中包含换行符），但它们并不是因为使用双引号 (") 而能够这样做的。实际上，模板字面量使用反引号 (`) 来定义。

C. 错误。模板字面量确实为字符串提供了更多的功能，特别是通过字符串插值（String Interpolation）的能力，但它们并不“添加任何功能”到字符串类型本身；它们提供了一种更强大、更灵活的字符串创建方式。

D. 正确。模板字面量允许你创建可以跨越多行的字符串，并且可以通过 ${} 语法将变量的值或表达式的计算结果直接嵌入到字符串中，这被称为字符串插值。

E. 正确。虽然模板字面量本身不直接执行 HTML 转义（如 A 选项所述），但它们可以通过在 ${} 表达式中调用转义函数来确保字符串安全地嵌入到 HTML 中。这种过程通常被称为 HTML 转义，用于防止跨站脚本攻击（XSS）。

#### 9

Which of the following are valid reasons to use context in React?

A. Shares props with a component's parent

B. Shares data considered "global" for a tree of React components

C. Avoids using classes in React development

D. Gives all components access to state

E. Avoids passing props through intermediate elements

E

在 React 中，使用 context 的哪些是有效原因？

A. 与组件的父级共享 props

B. 为 React 组件树中的“全局”数据提供共享

C. 避免在 React 开发中使用类

D. 使所有组件都能访问状态

E. 避免通过中间元素传递 props

#### 10

A developer is attempting to enable a React,js application for production using the webpack configuration file below.
However, the application continues to only operate with a development configuration. Which of the following can enable production for this
application?

```javascript
var debug = process.env.NODE_ENV == "production";
var webpack = require("webpack");
module.exports = {
  context: __dirname,
  devtool: debug ? "inline-sourcemap" : null,
  entry: "./js/scripts.js",
  output: {
    path: __dirname + "/js",
    filename: "scripts.min.js",
  },
  plugins: debug
    ? []
    : [
        new webpack.optimize.DedupePlugin(),
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.UglifyJsPlugin({
          mangle: false,
          sourcemap: false,
        }),
      ],
};
```

A. The process.env.NODE_ENV conditional statement should be "!==".

B. Deployment configurations require deployment modules to be added that coincide with the webpack module.

C. The entry file name should be changed to "scripts.min.js".

D. NODE_Env can be set to "debug" when the webpack is started with command line/terminal.

E. The new webpack.optímize.DedupePlugin() plugin should be removed.

A

一个开发者正在尝试使用下面的 webpack 配置文件来启用 React.js 应用的生产环境。然而，应用仍然只能以开发配置运行。以下哪个选项可以启用这个应用的生产环境？

A. process.env.NODE_ENV 的条件语句应该使用 "!=="。

B. 部署配置要求添加与 webpack 模块相匹配的部署模块。

C. 入口文件名应该改为 "scripts.min.js"。

D. 当通过命令行/终端启动 webpack 时，可以将 NODE_Env 设置为 "debug"。

E. 应该移除 new webpack.optímize.DedupePlugin() 插件。

解释：

在这个问题中，我们需要找出哪个选项能够使得 React.js 应用在生产环境下正确运行，而当前它似乎只以开发配置运行。我们来看每个选项：

A. 错误。process.env.NODE_ENV 的条件判断使用 == 是正确的，因为这里是在比较环境变量的值是否为字符串 "production"。使用 !== 会导致逻辑反转，这不是我们想要的结果。

B. 错误。Webpack 的部署配置并不要求添加与 webpack 模块相匹配的特定“部署模块”。Webpack 的配置主要依赖于其配置文件（如 webpack.config.js），而不是额外的模块。

C. 错误。题目中的 webpack 配置文件中，output.filename 已经被正确设置为 "scripts.min.js"，这是生产环境通常使用的文件名，因为它表示该文件是经过压缩的。因此，不需要更改入口文件名。

D. 正确。虽然这个选项的表述有些误导（通常我们不会在启动 webpack 时将 NODE_Env 设置为 "debug"，而是会设置为 "production"），但问题的核心在于确保 NODE_ENV 环境变量被正确设置。如果 NODE_ENV 没有被设置为 "production"，那么 debug 变量将为 true，导致 webpack 使用开发配置（如包含源代码映射等）。因此，确保在启动 webpack 之前通过命令行/终端正确设置 NODE_ENV=production 是使应用在生产环境下运行的关键。

E. 错误。webpack.optimize.DedupePlugin() 插件用于在生产环境中删除重复的模块，以减少最终构建文件的大小。这是一个有用的优化，不应该被移除。

#### 11

A developer must validate a prop as any number from 1 to 10.
Which of the following Reactjs code snippets will be added to the code below to correctly perform this validation?

```jsx
import React from "react";
import { PropTypes } from "prop-types";
const Number = (props) => {
  return (
    <div>
      <p>Number:{props.num}</p>
    </div>
  );
};

export default Number;
```

A.

```javascript
Number.propTypes = { num: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] };
```

B.

```javascript
Number.propTypes = {
  num: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
};
```

C.

```javascript
Number.propTypes = {
  num: PropTypes.objectOf(1 - 10),
};
```

D.

```javascript
Number.propTypes = {
  num: PropTypes.arrayOf(1 - 10),
};
```

E.

```jsx
const Number = (props) => {
  const { num } = props;
  if (num > 0 && num <= 10) {
    console.log("Good number!");
  } else {
    console.log("out of range number!");
  }

  return <p>Your Number is: {num}</p>;
};
Number.propTypes = {
  num: PropTypes.number,
};
export default Number;
```

B

开发者必须验证一个 prop 是否为 1 到 10 之间的任意数字。以下哪个 Reactjs 代码片段将被添加到下面的代码中，以正确执行此验证？

解释：

A 选项尝试将 num 设置为一个数组，但这不是 PropTypes 的有效用法。PropTypes 不支持直接将 prop 定义为数组中的具体值，除非使用 PropTypes.oneOf。

B 选项是正确的。PropTypes.oneOf 允许你指定一个对象应该严格等于数组中的某一个值。在这个例子中，它确保了 num 必须是 1 到 10 之间的一个数字。

C 选项使用 PropTypes.objectOf，这是不正确的，因为 PropTypes.objectOf 用于验证对象的值，而题目要求验证的是一个数字。

D 选项使用 PropTypes.arrayOf，这同样是不正确的，因为 PropTypes.arrayOf 用于验证数组，而题目要求验证的是一个单独的数字。

E 选项虽然在组件内部实现了对 num 的范围验证，但它没有直接使用 PropTypes 来限制 num 的值必须在 1 到 10 之间。因此，虽然它在功能上满足了要求，
但不符合题目中“使用 PropTypes 进行验证”的明确要求。

#### 12

A developer must fix an issue with a React application that is causing memory leaks by subscribing to the observable multiple times.
Which of the following will be added to the code below to resolve this issue?

```jsx
import React, { useEffect, useState } from "react";
function simpleExample() {
  let [userCount, setUserCount] = useState(0);
  useEffect(() => {
    someRandomObservable.subscribe((data) => {
      console.log(data);
    });
  });

  useEffect(() => {
    document.getElementById("username").value = "Bob";
  });

  return (
    <div>
      <b>User Count:{userCount}</b>
      <input
        type="button"
        onclick={() => setUserCount(userCount + 1)}
        value="Add Employee"
      />
    </div>
  );
}
```

A. Another state to the component with a setUnsubscribe function:
let [unsubscribe, setUnsubscribe] = useState();

B. A componentWillUnmount lifecycle method:
componentWillUnmount(){
someRandomObservable.unsubscribe()
}

C. Another button with an onclick function that calls an unsubscribe:

```jsx
<input type="button" onclick={() => someRandomObservable.unsubscribe()} />
```

D. An anonymous return function with an unsubscribe to the useEffect () hook that subscribes to the observable:

```jsx
return () => {
  someRandomObservable.unsubscribe();
};
```

E. A someRandomObservable.unsubscribe () into the existing onclick function:

```jsx
<input
  type="button"
  onclick={() => {
    setUserCount(userCount + 1);
    someRandomObservable.unsubscribe();
  }}
/>
```

D

开发者必须修复一个 React 应用程序中的问题，该问题通过多次订阅可观察对象（observable）导致内存泄漏。以下哪些内容将被添加到以下代码中以解决此问题？

A. 组件中带有 setUnsubscribe 函数的另一个状态：

B. 一个 componentWillUnmount 生命周期方法：

C. 另一个带有 onclick 函数的按钮，该函数调用 unsubscribe：

D. 一个带有取消订阅的匿名返回函数，作为 useEffect 钩子中订阅 observable 的清理函数：

E. 将 someRandomObservable.unsubscribe() 添加到现有的 onclick 函数中：

解释：

这个问题是关于如何在 React 组件中正确管理 RxJS（或类似库）中的 Observable 订阅，以避免内存泄漏。在 React 中，通常使用 useEffect 钩子来处理副作用，包括订阅和取消订阅 Observable。当组件卸载或依赖项变化时，应确保取消订阅，以防止内存泄漏。

现在，我们来分析每个选项：

A. 另一个状态来保存 unsubscribe 函数：虽然这看起来是一个管理 unsubscribe 函数的可行方法，但在这个特定的例子中，我们不需要额外的状态来存储 unsubscribe 函数，因为我们可以在 useEffect 的清理函数中直接调用它。

B. componentWillUnmount 生命周期方法：componentWillUnmount 是类组件中的生命周期方法，不适用于函数组件。在函数组件中，我们使用 useEffect 的清理函数来替代。

C. 另一个按钮来调用 unsubscribe：虽然这可以工作，但它不是处理 Observable 订阅的正确方式。用户不应该被允许通过 UI 来控制订阅的取消，这可能会导致应用行为不一致或出错。

D. 在 useEffect 钩子中返回一个匿名函数来取消订阅：这是处理 React 中 Observable 订阅的正确方式。通过在 useEffect 中返回一个函数，我们可以在组件卸载或依赖项变化时取消订阅，这是防止内存泄漏的关键。

E. 在现有的 onclick 函数中调用 someRandomObservable.unsubscribe()：这种方法会在每次点击按钮时都取消订阅，这会导致 Observable 的订阅被意外取消，影响组件的正常功能。

#### 13

Which of the following correctly describe differences between state and props within React js lifecycle events?

A. this.props can be updated regardless of lifecycle event, while this.state never changes.

B. this.state must be treated as if it is mutable regardless of lifecycle event, while this.props becomes immutable.

C. this.props is defined within a React.js component during the render() event, while this.state is initialized within the
constructor.

D. this.state cannot be used within a render() event, while this.props is initialized abstractly within the constructor.

E. this.state contains data specific to the component but may have the ability to change over time in multiple events,
while this.props contains static content that never changes.

E

以下哪些选项正确地描述了 React.js 生命周期事件中状态和属性（props）之间的差异？

A. 无论生命周期事件如何，this.props 都可以被更新，而 this.state 从不改变。

B. 无论生命周期事件如何，this.state 必须被视为可变的，而 this.props 变得不可变。

C. this.props 是在 React.js 组件的 render() 事件中被定义的，而 this.state 是在构造函数中初始化的。

D. this.state 不能在 render() 事件中使用，而 this.props 是在构造函数中抽象地初始化的。

E. this.state 包含特定于组件的数据，但可能在多个事件中随时间变化，而 this.props 包含永远不会改变的静态内容。

解释：

A. 错误。this.props 是由父组件传递给子组件的，并且它们在整个组件的生命周期内是不可变的（immutable）。this.state 可以在组件的生命周期内被更新，但这通常是通过设置新的状态值来完成的，而不是直接修改 this.state。

B. 错误。this.state 确实是可变的，但这并不意味着你应该在任何时候都当作它是可变的来处理。相反，你应该只在适当的时候（如响应用户输入或数据加载完成时）更新状态。this.props 确实是不可变的，但这不是因为生命周期事件，而是由 React 的设计决定的。

C. 正确。this.props 是在组件的 render() 方法中被访问的，但它们并不是在 render() 方法中定义的。它们是在组件创建时由父组件传递给子组件的。而 this.state 是在组件的构造函数（constructor）中初始化的，并且可以在组件的生命周期内被更新。

D. 错误。this.state 可以在 render() 方法中被使用，这是最常见的用法之一，因为状态的变化通常会导致组件的重新渲染。而 this.props 并不是在构造函数中抽象地初始化的，它们是由父组件在创建子组件时传递的。

E. 正确。this.state 包含了组件特有的数据，这些数据可能会随着时间的推移在多个事件中被更改。而 this.props 包含了静态内容，这些内容一旦由父组件传递给子组件，就不会在子组件内部改变（尽管父组件可以更改传递给子组件的 props）。

#### 14

A React component keeps producing a waring to set error boundaries,
Which of the following code snippets will be added to the ErrorBoundary component below to catch errors in the tree?

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  render() {
    return this.props.children;
  }
}
```

A. Add componentDidCatch() that logs the error to an error reporting service when there is an error.

B. Add static getDerivedStateFromError() to change the hasError property in state to true when it is triggered.

C. Add a try / catch block in render()

D. Add to render() to conditionally show the user something went wrong:

```jsx
if (this.state.hasError) {
  return <h1>something went wrong</h1>;
}
```

E. Add componentDidMount() to change the hasError property in state to true when there is an error.

A B D

React 组件持续产生设置错误边界的警告，以下哪些代码片段将被添加到下面的 ErrorBoundary 组件中以捕获树中的错误？

A. 添加 componentDidCatch()，在出现错误时将错误记录到错误报告服务。

B. 添加 static getDerivedStateFromError()，在触发时将状态中的 hasError 属性更改为 true。

C. 在 render() 中添加一个 try / catch 块。

D. 在 render() 中添加条件语句以向用户显示出现了问题：

E. 添加 componentDidMount()，在出现错误时将状态中的 hasError 属性更改为 true。

解释：

A. componentDidCatch() 是 React 中的一个生命周期方法，专门用于捕获子组件树中抛出的 JavaScript 错误，并打印错误日志或执行一些恢复操作。但是，它并不直接用于将错误日志发送到错误报告服务，而是提供了一个机会来处理错误并可能进行日志记录。然而，这个选项没有直接回答如何将错误捕获到 ErrorBoundary 组件中，而是描述了 componentDidCatch() 的一个可能用途。因此，虽然 componentDidCatch() 是必要的，但它不是直接添加到 render() 方法或改变组件状态的答案。

B. static getDerivedStateFromError(error) 是一个静态方法，它会在捕获到子组件树中的错误后被调用。这个方法允许你根据错误来更新状态，从而可以反映组件树中的错误状态。在这个场景中，将 hasError 属性设置为 true 是合适的，因为这样可以触发 UI 的改变来显示错误消息。这个选项直接回答了如何将错误捕获到 ErrorBoundary 组件中，并通过更新状态来反映错误的存在。

C. 在 render() 方法中添加 try / catch 块不会捕获到子组件树中抛出的错误。try / catch 只能捕获到当前函数执行过程中抛出的错误，而不能捕获到异步代码或子组件中抛出的错误。因此，这个选项是错误的。

D. 这个选项展示了如何在 render() 方法中根据 hasError 状态的值来条件性地显示错误消息。当 hasError 为 true 时，显示错误消息；否则，显示子组件。这是处理错误边界并通知用户出现问题的一种有效方式。这个选项与 static getDerivedStateFromError() 一起工作，共同构成了完整的错误边界实现。

E. componentDidMount() 是一个生命周期方法，它在组件挂载后立即调用。它不会捕获到子组件树中抛出的错误，因为它只在组件首次渲染到 DOM 后执行，并且此时所有的子组件也已经渲染。因此，这个选项不适用于错误边界的实现。

#### 15

The --inline and --hot parameters on webpack-dev-server do not appear to be working due to multiple re-loading HMR threads and content changes.
Which of the following are possible ways webpack-dev-server can reload changes by using --hot or --inline?

A. Add an entry to webpack.config.js like:

```javascript
devServer: {
  inline: true,
  hot: false,
};
```

B. Perform the npm commands: npm run dev

C. Install webpack-dev-server globally using; npm install webpack-dev-server -save

D. Add an entry to the scripts object of package.json like:

```json
{
  "scripts": {
    "start": "webpack-dev-server --hot --inline"
  }
}
```

E. Run a command vla terminal/command line specifying a unique port to use: webpack-dev-server --hot --port=8081

A

webpack-dev-server 上的--inline 和--hot 参数似乎由于多个 HMR 线程重新加载和内容更改而不起作用。以下哪些是 webpack-dev-server 使用--hot 或--inline 重新加载更改的可能方式？

A. 在 webpack.config.js 中添加一个条目，如：

B. 执行 npm 命令：npm run dev

C. 使用 npm install webpack-dev-server -save 全局安装 webpack-dev-server

D. 在 package.json 的 scripts 对象中添加一个条目，如：

E. 通过命令行/终端运行一个命令，指定一个要使用的唯一端口：webpack-dev-server --hot --port=8081

webpack-dev-server 是一个小型的 node.js Express 服务器，它使用 webpack-dev-middleware 中间件来为通过 webpack 打包生成的资源文件提供 Web 服务。在使用 webpack-dev-server 时，--inline 和 --hot 选项分别提供了不同的功能，它们在自动刷新和模块热替换（Hot Module Replacement, HMR）方面有所区别。

webpack-dev-server --inline
功能描述：当使用 --inline 选项时，webpack-dev-server 会为入口页面添加“热加载”功能。这意味着，当代码发生变化时，整个页面会重新加载以反映这些变化。但这里的“热加载”并不等同于 HMR，因为它实际上是通过重新加载整个页面来实现的，而不是只替换变化的模块。
实现方式：在 inline 模式下，webpack-dev-server 会将一个小型的客户端作为入口文件的一部分打包进去。这个客户端会监听后端代码的变化，并在检测到变化时刷新页面。
使用场景：当你不需要模块级别的热替换，而是希望每次代码变化时都刷新整个页面来查看最新效果时，可以使用 --inline 选项。
webpack-dev-server --hot
功能描述：--hot 选项启用了 webpack 的模块热替换（HMR）功能。这意味着，在开发过程中，当某个模块的代码发生变化时，webpack 会重新编译这个模块，并通过 webpack-dev-server 将更新的模块发送到浏览器。浏览器端的 HMR 运行时（runtime）会接收到这些更新的模块，并尝试替换掉旧的模块，而无需刷新整个页面。
实现方式：在 hot 模式下，webpack-dev-server 使用 WebSocket 来与浏览器端的 HMR 运行时通信。当检测到文件变化时，webpack 会重新编译，并通过 WebSocket 将更新推送到浏览器。浏览器端的 HMR 运行时接收到更新后，会尝试进行模块替换。
使用场景：当你希望在开发过程中保持应用的状态（如用户输入、滚动位置等）不变，同时又能即时看到代码变化的效果时，可以使用 --hot 选项。这对于提升开发效率和体验非常有帮助。
注意：在实际使用中，通常会将 --inline 和 --hot 选项一起使用（如 webpack-dev-server --inline --hot），以获得最佳的开发体验。但请注意，随着 webpack 和 webpack-dev-server 的更新，具体的选项和用法可能会有所变化。因此，建议查阅最新的官方文档以获取最准确的信息。

#### 16

A developer is adding a custom footer to a React.js application.
The component will not render and only displays the tag'<'paymentfooter '>'.
Based on the code below, which of the following correctly describe how the component can be remedied to properly render within the web page?

```jsx
import React from "react";
function paymentfooter(props) {
  return <div>Payment Confirmation: ${props.amount}</div>;
}
function renderPaymentFooter() {
  return <paymentfooter amount="10.00" />;
}
```

A. When translating to JSX, paymentFooter should be capitalized to ensure React,js understands it is not HTML markup:

```jsx
function renderPaymentFooter() {
  return <PaymentFooter amount="10.00" />;
}
```

B. this.state should be used instead of this.props:

```jsx
function paymentfooter(props) {
  return <div>Payment Confirmation: ${this.state.amount}</div>;
}
```

C.The "$" within the Jsx is considered an illegal character and should be removed!

```jsx
function paymentfooter(props) {
  return <div>Payment Confirmation:{props.amount}</div>;
}
```

D. The payment footer function name should be capitalized so React.js can transpile it as a component

```jsx
function PaymentFooter(props) {
  return <div>Payment Confirmation: ${props.amount}</div>;
}
```

E. When creating child JSX elements, ref should be used:

```jsx
import React from "react";
function paymentfooter(props) {
  return React.createRef();
}
function renderPaymentFooter() {
  return this.ref.current;
}
```

A D

一个开发者正在向 React.js 应用程序添加一个自定义页脚。组件不会渲染，并且只显示标签'<'paymentfooter'>'。基于下面的代码，哪些选项正确地描述了如何修复该组件以在网页中正确渲染？

A. 在转换为 JSX 时，paymentFooter 应该大写以确保 React.js 理解它不是 HTML 标记：

B. 应该使用 this.state 而不是 this.props：

C. JSX 中的"$"被视为非法字符，应该被移除！

D. payment footer 函数名称应该大写，以便 React.js 可以将其编译为组件

E. 在创建子 JSX 元素时，应使用 ref：

解释：

A. 正确。在 React 中，所有自定义的组件名称都应该以大写字母开头，以便 React 能够区分它们是组件还是 HTML 元素。在原始代码中，'<'paymentfooter amount="10.00" /> 被当作了一个 HTML 标签，因为它以小写字母开头，而实际上它应该是一个 React 组件。将 paymentfooter 改为 PaymentFooter 并在 JSX 中使用 '<'PaymentFooter amount="10.00" /> 是正确的做法。

D. 正确。这实际上是 A 选项的另一种表述方式，强调了函数组件名称应该大写，以便 React 能够正确识别并渲染它作为组件。

错误选项解释：

B. 错误。在函数组件中，通常使用 props 而不是 this.state。this.state 主要用于类组件中，用于管理和更新组件的内部状态。在这个例子中，amount 是一个传递给组件的 prop，所以应该使用 props.amount。

C. 错误。在 JSX 中，$ 是一个合法的字符，并且在这个上下文中用于表示货币单位。问题在于 paymentfooter 组件名的小写形式，而不是 $ 字符。

E. 错误。ref 在 React 中通常用于访问 DOM 元素或子组件的实例。在这个问题中，ref 并不是解决组件不渲染问题的正确方法。此外，renderPaymentFooter 函数中的 this.ref.current 引用也是错误的，因为 this 在这个函数组件的上下文中未定义，且 renderPaymentFooter 并没有使用 ref。

#### 17

Which of the following messages are displayed after executing the JavaScript code below?

```jsx
const greet = () => {
  var msg = ["Hello", this.name, "welcome to", this.location].join("");
  console.log(msg);
};
const person = { name: "Jane Doe", location: "Springfield" };
greet.call(this.person);
```

A. undefined

B. TypeError

C. Hello Jane Doe welcome to Springfield

D. Null

E. Hello welcome to

B

执行以下 JavaScript 代码后，将显示哪些消息？

B. TypeError：
当使用 greet.call(this.person);时，this 在全局作用域中通常指向全局对象（在浏览器中是 window 对象，在 Node.js 中是 global 对象），但这里 this.person 很可能未定义（除非在全局作用域中显式定义了 person 作为 this 的属性，这在常规情况下是不常见的）。因此，this.person 会是 undefined，然后 greet.call(undefined);会被调用。
在 JavaScript 中，如果 call 或 apply 的第一个参数（即 this 的值）是 null 或 undefined，它们会自动将 this 替换为全局对象（在严格模式下为 undefined）。但是，由于 greet 函数内部使用了 this.name 和 this.location，且没有严格模式声明（虽然这不影响 this 的自动替换行为，但会影响 this 为 undefined 时的行为），这些引用会尝试访问全局对象的 name 和 location 属性，如果这些属性不存在，则它们本质上是 undefined。然而，这里的主要问题是 this 的上下文不正确导致的潜在问题，以及如果 this 被严格地视为 undefined（在严格模式下），则直接访问 this.name 和 this.location 会抛出 TypeError，因为 undefined 没有属性。
但在非严格模式下，如果全局对象中没有 name 和 location 属性，则这些属性访问将简单地返回 undefined，但这不会直接导致 TypeError。然而，由于 join("")会将 undefined 转换为字符串"undefined"，所以最终的结果可能不是预期的"Hello Jane Doe welcome to Springfield"，但这不直接导致 TypeError。但考虑到题目可能是在询问潜在的问题或错误，TypeError 是由于 this 上下文不正确（尽管这里的 TypeError 不是直接由 join 方法引起的，而是由不恰当的 this 使用引起的潜在问题）而选出的。

#### 18

Which of the following code snippets demonstrate the proper techniques to handle the HTML event in React.js?

A.

```jsx
<button onClick="{activateLargePrint}">Activate Large Print</button>
```

B.

```jsx
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>
```

C.

```jsx
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log("The link was clicked.");
  }
  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}
```

D.

```jsx
<button onclick="activateLargePrint()">Activate Large Print</button>
```

E.

```jsx
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
```

C E

以下哪些代码片段展示了在 React.js 中处理 HTML 事件的正确技术？

理由：

A. 错误。这个选项中的 onClick 属性被错误地包裹在了花括号{}中，这会导致 React 将其视为一个对象字面量或 JavaScript 表达式的尝试，而不是一个函数引用。正确的写法应该是 onClick={activateLargePrint}（假设 activateLargePrint 是一个已经定义的函数）。

B. 错误。这个选项使用了原生的 onclick 属性而不是 React 的 onClick 属性。在 React 中，应该使用驼峰命名法的 onClick 来绑定事件处理器。此外，它还在 HTML 属性中直接写入了 JavaScript 代码，这是 React 中不推荐的做法。

C. 正确。这个选项展示了在 React 中处理链接点击事件的正确方法。它定义了一个名为 handleClick 的函数，该函数在点击事件发生时被调用，并使用 e.preventDefault()来阻止链接的默认行为（即跳转）。然后，这个函数被作为 onClick 属性的值传递给了a标签。

D. 错误。这个选项同样使用了原生的 onclick 属性，并且尝试在 HTML 属性中直接调用函数（通过 activateLargePrint()）。在 React 中，你应该传递一个函数引用给事件处理器，而不是调用它。

E. 正确（但需注意上下文）。这个选项展示了如何在 React 中处理按钮点击事件，并传递了额外的参数（id）和事件对象（e）给组件的方法（this.deleteRow）。然而，需要注意的是，如果这段代码是在一个类组件中，那么它是正确的；但如果在函数组件中，this 关键字将不会指向组件实例，因此可能会引发错误。不过，就题目本身而言，它并没有限定是在类组件还是函数组件中使用，所以我们假设这是一个类组件中的用法，因此这个选项是正确的。

#### 19

Which of the following JavaScript code snippets correctly use destructuring?

A.

```javascript
const fruits = ["apple", "orange", "banana"];
const [fruit1, fruit2, fruit3] = fruits;
```

B.

```javascript
const { numbers } = [1, 2, 3, 4, 5, 6];
```

C.

```javascript
const names = ["Jim", "Joe", "Carl", "Gary"];
let { name1, name2 } = names;
```

D.

```javascript
const cat = { name: "Fluffball", breed: "Calico", owner: "Bob" };
const { name, breed, owner } = cat;
```

E.

```javascript
const myString = "xyz";
const { a, b, c } = myString;
```

A D

以下哪些 JavaScript 代码片段正确地使用了解构？

理由：

A. 正确。这段代码使用了数组解构（Array Destructuring）来从 fruits 数组中提取出前三个元素，并将它们分别赋值给 fruit1、fruit2、fruit3 变量。

B. 错误。这段代码尝试从数组中解构出一个名为 numbers 的属性，但这是不正确的，因为数组解构通常用于访问数组中的元素，而不是对象中的属性。在对象解构中，我们可以根据属性名来解构值，但在数组中，我们必须根据索引位置来解构。

C. 错误。这段代码尝试从数组中解构出两个名为 name1 和 name2 的属性，但这是不可能的，因为数组解构是根据索引来访问元素的，而不是根据属性名。要正确地从这个数组中提取 name1 和 name2，我们应该使用数组解构的方式，即 let [name1, name2] = names;。

D. 正确。这段代码使用了对象解构（Object Destructuring）来从 cat 对象中提取出 name、breed、owner 三个属性，并将它们分别赋值给同名的变量。

E. 错误。这段代码尝试从字符串 myString 中解构出 a、b、c，但这是不正确的，因为字符串并不是对象或数组，不支持解构操作。在 JavaScript 中，字符串被当作一个不可变的字符序列，你不能直接通过解构来访问它的字符，尽管你可以通过字符串的索引或 split 等方法来访问或处理它们。

#### 20

Which of the following statements correctly describe Render Props in React.js?

A. The practice of using props directly within JSX markup

B. A simple technique for sharing code between React.js components using a prop that has a function as a value.

C. A technique for updating properties after they have been populated within a component.

D. An autonomous process that validates props values before they are inserted into a component.

E. The process of updating this.state with this.props values

B

以下哪些陈述正确地描述了 React.js 中的 Render Props？

A. 在 JSX 标记中直接使用 props 的实践

B. 使用值为函数的 prop 在 React.js 组件之间共享代码的一种简单技术。

C. 在组件内部填充属性后更新这些属性的技术。

D. 一个自主过程，它在将 props 值插入组件之前验证这些值。

E. 使用 this.props 值更新 this.state 的过程

理由：

A. 错误。这个描述并不特指 Render Props。在 React.js 中，直接使用 props 在 JSX 标记中是常见的做法，但它不是 Render Props 的定义。Render Props 是一种特定的模式，而不是简单地使用 props。

B. 正确。Render Props 是 React.js 中一种用于组件间共享代码的简单技术，它通过将函数作为 prop 的值来实现。这种模式允许组件将它的渲染逻辑以 props 的形式传递给子组件，子组件接收这个函数并执行，通常返回 JSX 来渲染。

C. 错误。这个描述与 Render Props 无关。它更像是描述了一种属性更新后的处理逻辑，而不是 Render Props 的核心概念。

D. 错误。这个描述并不准确描述 Render Props。Render Props 不涉及在组件中插入 props 值之前的验证过程。

E. 错误。这个描述与 React.js 中的状态更新过程相关，但与 Render Props 无关。Render Props 主要涉及组件之间的渲染逻辑共享，而不是状态更新。

#### 21

Which of the following correctly identify what will be displayed after executing the JavaScript code snippet below?

```jsx
class Polygon {
  constructor(width, height) {
    var width = width;
    var height = height;
  }
}
class Rectangle extends Polygon {
  constructor(width, height) {
    super(width, height);
    this._color = "";
  }
  get area() {
    return this.width + this.height;
  }

  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
}

class Square extends Rectangle {
  constructor(side) {
    super(side, side);
    this._color = "";
  }

  get area() {
    return super.area;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
}
let r1 = new Rectangle(2, 3);
/* console message #1 */
console.log("area = " + r1.area);

r1.color = "red";
/*console message #2*/
console.log("color= " + r1.color);
let s1 = new Square(10);
/*console message #3 */
console.log("square side= " + s1.side);
/*console message #4*/
console.log("square area= " + s1.area);
```

A. Console message #3 will display "square side = undefined".

B. Console message #1 will display "area = NaN".

C. Console message #1 will display "area = 666"

D. Console message #2 will display "color = red"

E. Console message #4 wll display "area = 100"

A B D

以下哪些选项正确地识别了执行以下 JavaScript 代码段后将显示的内容？

运行结果
area = NaN
color= red
square side= undefined
square area= NaN

Console message #1 will display "area = NaN".

因为 undefined + undefined = NaN

#### 22

Which of the following correctly describe the JavaScript vulnerability Cross-Site Request Forgery (CSRF)?

A. CSRF allows an attacker to impersonate a valid user of a web site

B. CSRF allows an attacker to inject scripts into web pages and get them to run within the browser.

C. CSRF is an attack where the attacker attempts to take over the user's browser session by hijacking the session cookie.

D. The credentials used to initiate a CSRF attack are mostly obtained via phishing.

E. CSRF exploits the trust that a server has in the user's browser.

A D

以下哪些选项正确地描述了 JavaScript 漏洞跨站请求伪造（CSRF）？

A. CSRF 允许攻击者冒充网站的有效用户

B. CSRF 允许攻击者将脚本注入到网页中并在浏览器中运行它们

C. CSRF 是一种攻击，攻击者试图通过劫持会话 cookie 来接管用户的浏览器会话

D. 发起 CSRF 攻击所使用的凭证大多是通过钓鱼获得的

E. CSRF 利用了服务器对用户浏览器的信任

解释
A. CSRF allows an attacker to impersonate a valid user of a web site

正确。跨站请求伪造（CSRF）允许攻击者冒充合法用户在网站上执行操作。这是因为 CSRF 攻击利用了网站对用户的已认证状态（如会话 cookie）的信任，诱导用户在不知情的情况下向网站发送请求。
B. CSRF allows an attacker to inject scripts into web pages and get them to run within the browser.

错误。这个描述实际上是跨站脚本攻击（XSS）的特点，而不是 CSRF。XSS 允许攻击者将恶意脚本注入到网站中，当其他用户访问这些页面时，脚本会在用户的浏览器中执行。
C. CSRF is an attack where the attacker attempts to take over the user's browser session by hijacking the session cookie.

错误。虽然 CSRF 攻击涉及到了会话 cookie，但它并不是通过劫持会话 cookie 来完全控制用户的浏览器会话。CSRF 主要是利用用户已经通过身份验证的会话（如通过 cookie）来执行恶意请求。攻击者并不直接控制用户的浏览器会话，而是诱导用户在自己的浏览器中发出请求。
D. The credentials used to initiate a CSRF attack are mostly obtained via phishing.

错误。CSRF 攻击通常不需要直接从用户那里获取凭证（如用户名和密码）。相反，它依赖于用户已经通过身份验证的会话（如会话 cookie），并诱导用户在不知情的情况下执行恶意操作。虽然钓鱼攻击可能用于获取用户的凭证，但这些凭证并不是 CSRF 攻击的直接前提。
E. CSRF exploits the trust that a server has in the user's browser.

正确。CSRF 攻击正是利用了服务器对用户浏览器的信任。在用户的浏览器向服务器发送请求时，服务器通常会信任这些请求是用户有意发出的，特别是当请求中包含了有效的会话 cookie 时。攻击者通过伪造请求来利用这种信任，从而在用户不知情的情况下执行恶意操作。

#### 23

There is an issue within an eCommerce React.js application with how setstate is updated,
as the DOM does not reflect the latest changes from a shopping cart button click.
Based on the sample code below, which of the following statements are correct?

```jsx
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }
  componentDidMount() {
    this.refBtn.addEventListener("click", this.onClick);
  }
  componentWillUnmount() {
    this.refBtn.removeEventListener("click", this.onClick);
  }
  onClick = () => {
    this.setstate({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <button onClick={this.onClick}>Add</button>
      </div>
    );
  }
}
```

A. The onClick handler should implement a function to update the DOM because setState contains a synchronous thread:

```jsx
onClick = () => {
  this.setstate((state) => {
    return { count: state.count + 1 };
  });
};
```

B. The onClick handler should implement a function to update the DOM because setState contains an asynchronous thread.

```jsx
onClick = () => {
  this.setstate((state) => {
    return { count: state.count + 1 };
  });
};
```

C. The state object should be incremented directly within the onclick handler:

```jsx
onClick = () => {
  this.state.count++;
};
```

D. The onclick handler should return the state.count value incremented：

```jsx
onClick = () => {
  return this.state.count + 1;
};
```

E. The state object should be set directly within the onclick handler:

```jsx
onclick = () => {
  this.state.count = this.state.count + 1;
};
```

B

在一个 React.js 的电子商务应用中，存在关于如何更新 setState 的问题，因为 DOM 没有反映出购物车按钮点击后的最新更改。基于下面的示例代码，以下哪些陈述是正确的？

A. 点击事件处理器应该实现一个函数来更新 DOM，因为 setState 包含一个同步线程：

B. 点击事件处理器应该实现一个函数来更新状态，因为 setState 包含一个异步线程。

C. 状态对象应该在点击事件处理器中直接增加：

D. 点击事件处理器应该返回增加后的 state.count 值：

E. 状态对象应该在点击事件处理器中直接设置：

async 异步

#### 24

Which of the following statements correctly describe differences between React.PureComponent and React.Component?

A. PureComponent handles the shouldComponentUpdate lifecycle event and performs deep comparisons of state and props, while Component does not.

B. PureComponent handles the shouldComponentUpdate lifecycle event and performs shallow comparisons of state and props, while Component does not.

C. PureComponent will allow re-rendering for all children components when a context has changed, while component does not.

D. PureComponent allows for mutation of JavaScript components, while Component does not.

E. PureComponent allows for the creation of new functions, objects, and arrays within the render() event, while component does not.

B

以下哪些陈述正确地描述了 React.PureComponent 和 React.Component 之间的区别？

A. PureComponent 处理 shouldComponentUpdate 生命周期事件，并对 state 和 props 执行深比较，而 Component 则不会。

B. PureComponent 处理 shouldComponentUpdate 生命周期事件，并对 state 和 props 执行浅比较，而 Component 则不会。

C. 当 context 发生变化时，PureComponent 将允许所有子组件重新渲染，而 Component 则不会。

D. PureComponent 允许 JavaScript 组件的变异，而 Component 则不允许。

E. PureComponent 允许在 render()事件中创建新的函数、对象和数组，而 Component 则不允许。

选择理由：

A 选项错误，因为 React.PureComponent 实际上执行的是对 props 和 state 的浅比较（shallow comparison），而不是深比较（deep comparison）。深比较会检查嵌套对象的每个属性，而浅比较只检查对象的第一层属性是否相同。
B 选项正确，React.PureComponent 通过覆盖 shouldComponentUpdate 生命周期方法来实现对 props 和 state 的浅比较，以决定是否需要进行组件的重新渲染。如果 props 和 state 的浅比较结果显示没有变化，则 PureComponent 会阻止不必要的渲染，从而提高性能。而普通的 React.Component 默认情况下不会进行这样的比较，除非开发者在 shouldComponentUpdate 方法中手动实现。
C 选项错误，PureComponent 并不直接处理 context 的变化导致的重新渲染。context 的变化是否导致重新渲染取决于 context 的提供者和消费者是如何实现的，而不是由 PureComponent 或 Component 直接决定的。此外，PureComponent 的浅比较机制也仅针对 props 和 state，不包括 context。
D 选项错误，React.PureComponent 和 React.Component 都不应该允许对组件内部的 JavaScript 对象进行直接的变异（mutation）。在 React 中，推荐的做法是通过新的 props 或 state 来触发组件的重新渲染，而不是直接修改组件的内部状态。
E 选项错误，在 render()方法中创建新的函数、对象或数组是 React 组件的常见做法，无论是 PureComponent 还是 Component 都可以这样做。然而，如果这些新创建的对象或函数在每次渲染时都保持不变（即它们是纯的，不依赖于组件的 props 或 state），那么使用 PureComponent 可能不会带来性能上的好处，因为浅比较仍然会认为它们是不同的（因为它们是不同的引用）。

#### 25

When using Reactjs this .props validation, which of the following rules can be implemented to enforce that only one child is to be passed within this.props.children?

A. PropTypes.func.isRequired

B. PropTypes.string.isRequired

C. PropTypes.any.isRequired

D. PropTypes.objectOf(PropTypes.number).isRequired

E. PropTypes.element.isRequired

E

在使用 Reactjs 进行.props 验证时，以下哪些规则可以被实施来强制确保 this.props.children 内只传递一个子元素？

选择理由：
在 React 中，this.props.children 是一个特殊的 prop，用于访问传递给组件的子元素。如果你想要确保 this.props.children 只包含一个子元素（React 元素），你应该使用 PropTypes.element 来进行类型检查。这个校验器会确保传递给 children 的是一个 React 元素。

A 选项（PropTypes.func.isRequired）：这个校验器用于确保传入的属性是一个函数，并且该属性是必需的。它与 this.props.children 只包含一个子元素的需求不符。

B 选项（PropTypes.string.isRequired）：这个校验器用于确保传入的属性是一个字符串，并且该属性是必需的。它同样不适用于 this.props.children 的校验，因为 children 可能不是字符串。

C 选项（PropTypes.any.isRequired）：这个校验器表示传入的属性可以是任何类型，并且该属性是必需的。它不会限制 this.props.children 的数量或类型，因此不满足只传递一个子元素的要求。

D 选项（PropTypes.objectOf(PropTypes.number).isRequired）：这个校验器用于确保传入的属性是一个对象，且该对象的值都是数字。这与 this.props.children 的校验无关，因为 children 通常不是一个对象，而是 React 元素或元素的数组。

E 选项（PropTypes.element.isRequired）：这个校验器正好满足了只传递一个 React 元素作为 this.props.children 的需求。但是，请注意，即使你使用了这个校验器，如果组件接收了多个子元素，React 也不会阻止它们的渲染，而只是在开发模式下在控制台中显示一个警告。如果你需要严格限制只有一个子元素，你可能需要在组件内部进行检查，并在有多个子元素时抛出错误或进行其他处理。

#### 26

Two components must be in sync with each other. Which of the following can be implemented to have the components share state, based on the initial React code below?

```jsx
class Converter extends React {
  render() {
    return (
      <div>
        <WeightInput units="lbs" />
        <WeightInput units="kgs" />
      </div>
    );
  }
}
```

In the weightInput file;

```jsx
const weightNames = { lbs: "pounds", kgs: "kilograms" };
class weightInput extends React {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = { weight: "" };
  }
  handleChange(e) {
    this.setstate({ weight: e.target.value });
  }
  render() {
    const weight = this.state.weight;
    const units = this.props.units;
    return (
      <fieldset>
        <legend>Enter weight in {weightNames[weight]}:</legend>
        <input value={weight} onChange={this.handleChange} />
      </fieldset>
    );
  }
}
```

A. Give access of each weightInput component's state to the other WeightInput component's state so when one changes the other updates.

B. Remove the state and move it or "lift it up" from the child WeightInput component to the parent converter component and move the weightNames object to the Converter component as well .

C. Bind the handleChange method to the state in the WeightInput component.

D. Add onWeightChange, weight, and units to the WeightInput components as props in the converter component.
Also, add the handlePoundsChange and handleKilosChange methods in the Converter component along with binding them in the constructor.
This will allow state to be changed using this.setstate based on which input the user types the weight into:

```jsx
<WeightInput units="lbs" weight={pounds} onWeightChange={this.handlePoundsChange} />
<WeightInput units="kgs" weight={kilograms} onWeightChange={this.handleKilosChange}/>
```

E. Change the variable weight in the weightInput component and replace this.state.weight with this.props.temperature and change this.setState in the WeightInput component handleChange method to this.props.onWeightChange(e.target.value).

B D

两个组件必须相互同步。基于以下初始 React 代码，可以实现哪些方法来使组件共享状态？

A. 让每个 weightInput 组件的状态可以访问另一个 WeightInput 组件的状态，以便当一个更改时，另一个也更新。

B. 移除状态，并将其从子组件 WeightInput“提升”到父组件 converter 中，同时将 WeightNames 对象也移到 Converter 组件中。

C. 将 handleChange 方法绑定到 WeightInput 组件的状态中。

D. 在 converter 组件中，将 onWeightChange、weight 和 units 作为 props 添加到 WeightInput 组件中。同时，在 Converter 组件中添加 handlePoundsChange 和 handleKilosChange 方法，并在构造函数中绑定它们。这将允许根据用户在哪个输入框中输入重量，使用 this.setState 来改变状态：

E. 更改 weightInput 组件中的变量 weight，用 this.props.temperature 替换 this.state.weight，并在 WeightInput 组件的 handleChange 方法中，将 this.setState 更改为 this.props.onWeightChange(e.target.value)。

解释：

A：这个选项提出让每个 WeightInput 组件的状态互相访问，这在 React 中通常不是推荐的做法，因为它违反了组件的封装原则，并可能导致状态管理变得复杂和难以维护。
B：这个选项建议将状态从子组件 WeightInput“提升”到父组件 Converter 中。这是 React 中常用的状态提升（Lifting State Up）模式，有助于在多个组件间共享状态。同时，将 weightNames 对象也移到 Converter 组件中可以保持代码的组织性和可维护性。
C：这个选项提到将 handleChange 方法绑定到 WeightInput 组件的状态中，但实际上 handleChange 方法已经通过 this.handleChange.bind(this)在构造函数中绑定，并且其作用是更新组件的状态，而不是被状态绑定。因此，这个选项并不直接解决问题。
D：这个选项提出了一个具体的实现方式，即在 Converter 组件中管理状态，并通过 props 将状态和改变状态的方法（如 handlePoundsChange 和 handleKilosChange）传递给 WeightInput 组件。这样，当用户在一个输入框中输入重量时，可以通过调用传递给 WeightInput 的 onWeightChange 方法来更新 Converter 组件中的状态，从而实现两个输入框之间的同步。
E：这个选项建议更改 weightInput 组件中的变量名并替换 this.state.weight 和 this.setState 的用法，但这并不解决状态共享的问题。此外，将 this.state.weight 替换为 this.props.temperature 显然是一个逻辑错误，因为 temperature 与重量无关。

#### 27

Which of the following statements about JavaScript arrow functions are correct?

A. Arrow functions are anonymous functions.

B. The value of the "this" object in arrow functions is determined by the scope in which it is defined.

C. Arrow functions can be used as constructors.

D. JavaScript arrow functions expose the arguments object so they can use it to read parameter values.

E. When the body of an arrow function is wrapped in curly braces, the "return" keyword is needed to return a value.

A B E

关于 JavaScript 箭头函数的以下哪些陈述是正确的？

A. 箭头函数是无名函数。

B. 箭头函数中"this"对象的值由其定义的作用域决定。

C. 箭头函数可以用作构造函数。

D. JavaScript 箭头函数暴露 arguments 对象，因此它们可以使用它来读取参数值。

E. 当箭头函数的体被大括号包裹时，需要使用"return"关键字来返回值。

解释：

A. Arrow functions are anonymous functions.（箭头函数是无名函数。）

正确。箭头函数确实可以没有名称，它们经常用作匿名函数。
B. The value of the "this" object in arrow functions is determined by the scope in which it is defined.（箭头函数中"this"对象的值由其定义的作用域决定。）

正确。箭头函数不绑定自己的 this，而是继承自外围（即父级或词法）作用域中的 this 值。
C. Arrow functions can be used as constructors.（箭头函数可以用作构造函数。）

错误。箭头函数不能用作构造函数，因为它们没有自己的 this、arguments、super 或 new.target。尝试使用 new 关键字与箭头函数一起会抛出错误。
D. JavaScript arrow functions expose the arguments object so they can use it to read parameter values.（JavaScript 箭头函数暴露 arguments 对象，因此它们可以使用它来读取参数值。）

错误。箭头函数不绑定自己的 arguments 对象。相反，它们会继承外围（或父级）作用域的 arguments 对象（如果有的话），但在严格模式下，这通常不是预期的行为。更常见的是，箭头函数通过其参数列表直接访问参数值。
E. When the body of an arrow function is wrapped in curly braces, the "return" keyword is needed to return a value.（当箭头函数的体被大括号包裹时，需要使用"return"关键字来返回值。）

正确。如果箭头函数的体是一个代码块（即被大括号{}包围），并且需要返回值，那么必须使用 return 语句。如果箭头函数的体是一个表达式（没有大括号），那么表达式的值将自动作为函数的返回值。

#### 28

Which of the following statements are correct regarding strict mode in JavaScript?

A. The strict mode directive can be used anywhere in a module or function.

B. Strict mode will prevent errors caused by numeric overflow.

C. Strict mode can be applied to entire scripts or at the function level.

D. Strict mode prevents keywords that have been reserved for future use from being used.

E. Strict mode changes simple mistakes into syntax and run-time errors.

C D E

关于 JavaScript 中的严格模式，以下哪些陈述是正确的？

A. 严格模式指令可以在模块或函数的任何位置使用。

B. 严格模式将防止由数字溢出引起的错误。

C. 严格模式可以应用于整个脚本或在函数级别上。

D. 严格模式防止使用为未来保留的关键字。

E. 严格模式将简单的错误转变为语法和运行时错误。

解释：

A. The strict mode directive can be used anywhere in a module or function.（严格模式指令可以在模块或函数的任何位置使用。）

错误。虽然严格模式指令（即'use strict';）可以在脚本或函数的顶部声明，但它不能“在任何位置”使用。它必须出现在任何可执行代码之前，否则将不会生效。
B. Strict mode will prevent errors caused by numeric overflow.（严格模式将防止由数字溢出引起的错误。）

错误。严格模式不会直接影响数值运算，包括数值溢出。数值溢出（如当结果超出 JavaScript 能表示的最大或最小数值范围时）的行为在严格模式和非严格模式下是相同的。
C. Strict mode can be applied to entire scripts or at the function level.（严格模式可以应用于整个脚本或在函数级别上。）

正确。这是严格模式的一个关键特性。你可以通过在脚本或函数的顶部添加'use strict';来启用严格模式。
D. Strict mode prevents keywords that have been reserved for future use from being used.（严格模式防止使用为未来保留的关键字。）

正确。在严格模式下，尝试使用未来可能引入的 JavaScript 保留关键字作为变量名或函数名等将导致语法错误。
E. Strict mode changes simple mistakes into syntax and run-time errors.（严格模式将简单的错误转变为语法和运行时错误。）

正确。严格模式的主要目的之一是捕获一些常见的编码错误，并将它们从静默失败或难以追踪的运行时错误转变为易于调试的语法错误或明确的运行时错误。

#### 29

Which of the following sample React.js code snippets do not use JSX markup and are comparable to the JSX below?

```jsx
class Greeting extends React.Component {
  render() {
    return <div>Hello {this.props.name}</div>;
  }
}

ReactDOM.render(<Greeting name="John" />, document.getElementById("root"));
```

A.

```jsx
class Greeting extends React.Component {
  render() {
    return React.createElement("div", null, `Hello ${this.props.name}`);
  }
}
ReactDOM.render(
  React.createElement(Greeting, { name: "John" }, null),
  document.getElementById("root")
);
```

B.

```jsx
class Greeting extends React.Component {
  render() {
    return React.createElement(`Hello ${this.props.name}`);
  }
}
ReactDOM.render(
  React.createElement(Greeting, { name: "John" }, null),
  document.getElementById("root")
);
```

C.

```jsx
class Greeting extends React.Component {
  render() {
    return (
      <div>
        <User name="{this.props.name}" />
      </div>
    );
  }
}
ReactDOM.render(
  React.createElement(Greeting, { name: "John" }, null),
  document.getElementById("root")
);
```

D.

```jsx
class Greeting extends React.Component {
  const ref =React.createRef() // 这句声明在class中语法错误
  render() {
    return React.createElement(ref, null, `Hello ${this.props.name}`);
  }
}

ReactDOM.render(
  React.createElement(Greeting, { name: "John" }, null),
  document.getElementById("root")
);
```

E.

```jsx
class Greeting extends React.Component {
  render() {
    var element = document.createElement("div");
    element.innerText = `Hello ${this.props.name}`;
    return element;
  }
}

ReactDOM.render(
  React.createElement(Greeting, { name: "John" }, null),
  document.getElementById("root")
);
```

A

以下哪个 React.js 代码片段不使用 JSX 标记，并且与下面的 JSX 代码片段功能相当？

解释：

A 选项正确地使用了 React.createElement 来模拟 JSX 的渲染过程，这与给定的 JSX 代码片段在功能上是等价的。React.createElement 函数用于动态创建 React 元素，其参数与 JSX 的语法结构相对应。在这个例子中，它创建了一个 div 元素，并设置了其内部文本为"Hello " + this.props.name，这与 JSX 中的'<'div>Hello {this.props.name}'<'/div>效果相同。

其他选项分析：

B 选项错误地使用了 React.createElement。React.createElement 的第一个参数应该是字符串（表示 HTML 标签名）或 React 组件类，但在这里它被错误地设置为了一个模板字符串。

C 选项虽然使用了 JSX 语法，但其中包含了一个不存在的'<'User/>组件，且该组件的 name 属性被错误地包裹在双引号中，导致它不会被解析为 JavaScript 表达式，而是被当作字符串处理。此外，题目要求不使用 JSX，因此这个选项不符合要求。

D 选项在类定义中错误地尝试使用 const 声明 ref，这在类的方法外部是允许的，但在类的方法或属性中直接使用 const（尤其是在类的顶层）是不合法的。此外，React.createElement 的第一个参数应该是字符串或 React 组件类，而不是一个引用（ref）。

E 选项尝试使用原生 DOM API（document.createElement 和 element.innerText）来创建和设置元素，但这与 React 的渲染机制不兼容。React 使用虚拟 DOM 来优化 DOM 操作，并期望组件的 render 方法返回 React 元素（即使用 React.createElement 创建的元素或 JSX 表达式的结果），而不是原生 DOM 元素。

#### 30

Which of the following are examples of "side effects" in React?

A. Generating a component re-render

B. Setting up a subscription to an observable

C. Automatically updating the DOM element

D. Updating a global variable outside a function

E. Fetching data with asynchronous APl calls

B, D, E

以下哪些是 React 中“副作用”的例子？

A. 触发组件重新渲染

B. 设置对可观察对象的订阅

C. 自动更新 DOM 元素

D. 在函数外部更新全局变量

E. 通过异步 API 调用获取数据

解释：

A. Generating a component re-render（触发组件重新渲染）

这不是一个副作用。在 React 中，组件的重新渲染是响应式数据流的一部分，当组件的 props 或 state 改变时，React 会重新渲染该组件。这是 React 的核心特性之一，不属于副作用的范畴。
B. Setting up a subscription to an observable（设置对可观察对象的订阅）

这是一个副作用。在 React 组件中设置外部数据源的订阅（如 WebSocket、Redux store 的监听器等）会在组件外部产生效果，这些效果会影响组件的渲染，但它们不是渲染过程的一部分。
C. Automatically updating the DOM element（自动更新 DOM 元素）

这实际上不是 React 中的副作用，因为 React 通过其虚拟 DOM 机制来管理 DOM 的更新。React 的 render 方法输出的是虚拟 DOM 的描述，而不是直接操作 DOM。React 负责将虚拟 DOM 的变更转换为实际的 DOM 更新。这个过程对开发者来说是透明的，且不被视为副作用。
D. Updating a global variable outside a function（在函数外部更新全局变量）

这是一个副作用。在 React 组件中（或任何 JavaScript 环境中），直接修改全局变量会影响到应用的其他部分，这种影响超出了组件的局部作用域，因此被视为副作用。
E. Fetching data with asynchronous API calls（通过异步 API 调用获取数据）

这也是一个副作用。在 React 组件中，通过异步 API 调用获取数据是常见的操作，但这些操作会影响到组件的渲染（比如通过更新 state 来触发重新渲染），且它们不是 React 渲染过程的一部分。

#### 31

An airline web application built with React.js must request updated fight status data from a third-party RESTful web service after the application has loaded,
and then immediately update the DOM. Which of the following React.js lifecycle events can help in accomplishing this task?

A. The componentDidUpdate() event because it is used to perform updates on a DOM after the component props has changed and will still be invoked if shouldComponentUpdate() returns false.

B. The componentDidMount event because it is preferred for making network requests.

C. The getSnapshotBeforeUpdate() event because it is used to cache previous data before it is overwritten by a consecutive update and can easily be retrieved using componentDidUpdate()

D. A forceUpdate() event because using this.props and this.states update data more efficiently

E. The render() event because it can modify component state.

B

使用 React.js 构建的航空公司 Web 应用程序在加载后必须从第三方 RESTful 网络服务请求更新的航班状态数据，并立即更新 DOM。以下哪些 React.js 生命周期事件可以帮助完成这项任务？

A. componentDidUpdate() 事件，因为它用于在组件的 props 改变后更新 DOM，并且如果 shouldComponentUpdate()返回 false 也仍然会被调用。

B. componentDidMount 事件，因为它是执行网络请求的首选位置。

C. getSnapshotBeforeUpdate() 事件，因为它用于在连续更新覆盖之前缓存旧数据，并可以通过 componentDidUpdate()轻松检索。

D. forceUpdate() 事件，因为使用 this.props 和 this.state 更新数据更高效。

E. render() 事件，因为它可以修改组件状态。

解释：

A. 错误：componentDidUpdate() 是在组件的更新被 DOM 重新渲染之后立即被调用。虽然它确实可以在 DOM 更新后执行一些操作，但它不是加载后立即执行网络请求的理想选择，因为它依赖于组件的 props 或 state 发生变化。在这个场景中，我们需要在组件挂载后立即请求数据，而不是在其更新后。

B. 正确：componentDidMount() 是组件挂载到 DOM 后执行的第一个方法。这是一个理想的位置来执行网络请求，因为此时组件已经被渲染到 DOM 中，且可以安全地访问 DOM 和进行网络请求。

C. 正确（但注意它并不直接用于发起网络请求）：虽然 getSnapshotBeforeUpdate() 主要是用于在最近一次渲染输出被提交给 DOM 之前获取一些信息（例如，滚动位置），但它可以被视为与 componentDidUpdate() 配合使用来管理数据更新的一个环节。在这个场景下，虽然它本身不直接用于请求数据，但如果在 componentDidMount()中请求数据并在后续更新中需要用到旧数据，getSnapshotBeforeUpdate() 可以提供帮助。然而，就本问题而言，我们主要关注的是请求数据和更新 DOM，所以选择它主要是因为它与数据更新流程相关，并且暗示了数据更新的管理。

D. 错误：forceUpdate() 是一个强制组件重新渲染的方法，它并不用于请求数据。此外，频繁使用 forceUpdate() 可能会导致性能问题，因为它会绕过 React 的 shouldComponentUpdate()生命周期方法，导致不必要的渲染。

E. 错误：render() 方法是用于渲染组件的 UI 的，它应该是一个纯净的函数，只返回 JSX 或其他可渲染的 React 元素。它不应该用于修改组件的状态或执行副作用（如网络请求）。

#### 32

A developer debugging a React.js application is attempting to run the application locally with the terminal command npm start .env.
However, all the URL endpoints are pointing to production and the developer is not authorized to interact with production data systems.
Which of the following can configure the application to operate in a test environment?

A. Download the config npm module, set default and production JSON files, and configure the application to use default only.

B. Hardcode the test environment variables as constants within the React.js class files.

C. Update .env files to reflect the test instance and perform the same npm terminal command.

D. Create a copy of the .eny file and create a new file name (for example .env.test.local), change the required URLs, and reference the newly created configuration file using:npm start: .env.test.local

E. Create temporary environment variables and start npm without the .env file like: DATABASE URL=mongodb://mydatabase npm start

C

一个正在调试 React.js 应用程序的开发者尝试使用终端命令 npm start .env 在本地运行该应用程序。但是，所有的 URL 端点都指向生产环境，并且开发者没有权限与生产数据系统进行交互。以下哪项可以配置应用程序以在测试环境中运行？

A. 下载配置 npm 模块，设置默认和生产 JSON 文件，并配置应用程序仅使用默认设置。

B. 在 React.js 类文件中将测试环境变量硬编码为常量。

C. 更新 .env 文件以反映测试实例，并执行相同的 npm 终端命令。

D. 创建 .eny 文件的副本并创建新文件名（例如 .env.test.local），更改所需的 URL，并使用以下命令引用新创建的配置文件：npm start: .env.test.local

E. 创建临时环境变量并在不使用 .env 文件的情况下启动 npm，如：DATABASE_URL=mongodb://mydatabase npm start

解释：

在这个问题中，开发者正在尝试使用 npm start .env 命令在本地运行 React.js 应用程序，但所有的 URL 端点都指向生产环境，并且开发者没有权限与生产数据系统进行交互。目标是配置应用程序以在测试环境中运行。

A. 错误：下载配置 npm 模块，设置默认和生产 JSON 文件，并配置应用程序仅使用默认设置，这种方法通常用于多环境配置，但问题中未提及需要使用额外的 npm 模块或 JSON 文件进行配置，且.env 文件已经是 React 应用中常用的环境变量配置文件。

B. 错误：在 React.js 类文件中将测试环境变量硬编码为常量，这不是一个好的做法，因为它会使代码难以维护，特别是当环境变量发生变化时。此外，硬编码环境变量会破坏代码的灵活性和可移植性。

C. 正确：更新 .env 文件以反映测试实例，并执行相同的 npm 终端命令。在 React.js 应用程序中，.env 文件通常用于存储环境特定的配置，如 API 端点、数据库连接信息等。通过修改 .env 文件中的变量，可以轻松地更改应用程序的环境配置，使其指向测试环境而不是生产环境。

D. 错误：创建 .eny 文件的副本并创建新文件名（如 .env.test.local）是不正确的，因为通常使用的文件名是 .env 或以 .env 开头的文件名（如 .env.test）。此外，npm start: .env.test.local 这种命令格式在 npm 中不是有效的命令格式。通常，.env 文件会在应用程序启动时自动加载，无需在命令中指定。

E. 错误：创建临时环境变量并在不使用 .env 文件的情况下启动 npm，如 DATABASE_URL=mongodb://mydatabase npm start，虽然这种方法可以在命令行中临时设置环境变量，但它不是管理多个环境（如开发、测试和生产）配置的最佳实践。此外，这种方法要求开发者在每次启动应用程序时都手动设置环境变量，这既不方便也不安全。

#### 33

A developer working on a React js component must have more control over when a reference or Ref is set using a callback ref. which of the following code snippets correctly implement this concept?

A.

```jsx
function MyFunctionComponent() {
  return <input />;
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    return <MyFunctionComponent ref={this.textInput} />;
  }
}
```

B.

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

C.

```jsx
componentDidMount(){
this._input.focus()
}
render (){
return <TextInput ref={ (c)=> this._input = c} />;
}

```

D.

```jsx
class customTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;
    this.setTextInputRef = (element) => {
      this.textInput = element;
    };
  }

  render() {
    return (
      <div>
        <input type="text" ref={this.setTextInputRef} />
      </div>
    );
  }
}
```

E.

```jsx

```

C D , E???

以下哪些陈述描述了以下 TypeScript 代码片段中联合类型的使用？

一个正在开发 React js 组件的开发者必须在使用回调引用（callback ref）时拥有对何时设置引用（Ref）的更多控制权。以下哪些代码片段正确地实现了这个概念？

解释：
A 选项错误：在 React 中，你不能直接将 ref 属性用于函数组件 MyFunctionComponent，因为函数组件没有实例，所以 ref 不会自动附加到组件上。这个 ref 应该通过 forwardRef 转发到子组件中的 DOM 元素上。
B 选项错误：虽然这个类组件正确地创建了一个 ref 并将其附加到 div 元素上，但它并没有使用回调函数引用（callback ref）的方式，而是直接使用了 React.createRef() 创建的 ref。题目要求的是使用回调函数引用的方式。
C 选项正确：这个代码片段展示了如何在类组件的 render 方法中使用回调函数引用（callback ref）将 ref 附加到 TextInput 组件（假设这是一个自定义的或来自某个库的组件）的 DOM 元素上。这允许在组件挂载后（如 componentDidMount 中）直接访问该 DOM 元素。
D 选项正确：这个类组件通过定义 setTextInputRef 方法作为回调函数，并将这个方法作为 ref 的值传递给 input 元素。这种方式也允许组件在内部跟踪并访问该 DOM 元素，而无需使用 React.createRef()。

#### 34

A Reactjs web application performs validation when the user's mouse moves away from a form,
However, when the onBlur event triggers, the event argument is null. Based on the code below, which of the following resolve this issue?

```jsx
class ValidatedFormField extends React.Component {
  constructor(props) {
    super(props);
    this.handleBlur = this.handleBlur.bind(this);
  }
  handleBlur(event) {
    console.log("The element has blurred...performing validation");
    //TODO: need to add validation code here
  }
  render() {
    return (
      <input
        type="text"
        onBlur={this.handleBlur}
        name="{this.props.name}"
        placeholder={this.props.placeholder}
      />
    );
  }
}
ReactDoM.render(<ValidatedFormField />, document.getElementById("root"));
```

A.
Initialize the JSX input with an arrow function in the callback:

```jsx
 render() {
  return (
    <input
      type="text"
      onBlur={(e) => this.handleBlur(e)}
      name="{this.props.name}"
      placeholder="{this.props.placeholder}"
    />
  );
}
```

B. implement the native JavaScript onblur APl:

```jsx
 render() {
  return (
    <input
      type="text"
      onblur="handleBlur()"
      name="(this.props.name)"
      placeholder="{this.props.placeholder}"
    />
  );
}
```

C. Remove props from being passed to the super abstract class.

D. Use a public field syntax to bind the function:

```jsx
handleBlur = () => {
  console.log("The element has blurred...performing validation");
  //ToDo:need to add validation code here
};
```

E. Bind the onBlur function handler to this within the constructor: this.handleBlur = this.handleBlur.bind(this);

A, D, E

一个 Reactjs Web 应用程序在用户鼠标离开表单时进行验证，然而，当 onBlur 事件触发时，事件参数是 null。基于下面的代码，以下哪些方法可以解决这个问题？

A. 使用箭头函数在 onBlur 的回调中初始化 JSX 输入元素是正确的。这是因为箭头函数自动绑定了 this 上下文到其外围作用域（即 ValidatedFormField 类的实例），所以即使在回调中，this.handleBlur 也能正确引用到类的方法。这解决了在回调函数中 this 指向不正确的问题，也间接处理了如果事件参数 event 被意外修改或丢失的情况（虽然在这个具体例子中，event 参数为 null 的问题并不是由 this 指向引起的，但使用箭头函数是一种更安全的绑定事件处理器的方法）。

D. 使用类属性语法来定义 handleBlur 方法（即 handleBlur = () => {...}）也是一种自动绑定 this 到类实例的方法。这种方法直接在类定义中绑定了 this，避免了在构造函数中手动绑定。它同样确保了无论在哪里调用 handleBlur，this 都指向类的实例。

E. 在构造函数中通过 this.handleBlur = this.handleBlur.bind(this);绑定 handleBlur 方法是传统且有效的方式来确保在回调中 this 的正确性。这种方法在 React 类组件中非常常见，特别是在 ES6 类语法中，因为默认情况下，类的方法不会自动绑定 this 到类的实例。

#### 35

Updates to a React js application's source code can be reviewed: however, changes are not being reflected within the deployed version.
Which of the following actions ensure the application is deployed consistently?

A. Ensure all "watch" configurations are set to true within the watch options config.

B. Delete the package.json file from the project and rebuild the application.

C. Use the "webpack" command in the command line or terminal.

D. Add the "inline" or "hot" parameters if the webpack-dev-server module is invoked.

E. Add all required babel framework into webpack and ensure they are installed via npm commands.

C D E

React js 应用程序的源代码更新可以进行审查：然而，更改并未在已部署的版本中反映出来。以下哪些操作可以确保应用程序一致地部署？

A. 确保在观察选项配置中将所有“观察”配置设置为 true。

B. 从项目中删除 package.json 文件并重新构建应用程序。

C. 在命令行或终端中使用"webpack"命令。

D. 如果调用了 webpack-dev-server 模块，则添加"inline"或"hot"参数。

E. 将所有必需的 babel 框架添加到 webpack 中，并确保它们通过 npm 命令安装。

#### 36

Which of the following console messages will be displayed upon executing the JavaScript code below?

```tsx
class Person {
  constructor(fname, lname) {
    this.firstName = fname;
    this.lastName = lname;
  }
}

class Employee extends Person {
  constructor(fname, lname) {
    super(fname, lname);
  }
  get fullName() {
    return this, firstName + "" + this.lastName;
  }
  get position() {
    return this.position;
  }
  set position(value) {
    this.position = value;
  }
  get nickName() {
    return this.nickname;
  }
  set nickName(value) {
    this.nickname = value;
  }
}
let e1 = new Employee("Elizabeth", "Doe");
e1.position = "developer";

//Console message #1
console, log("full name: " + e1.fullName + ",position: " + e1.position);
let e2 = e1;
e1.nickName = "Beth*e2";
e2.nickName = "Liz";

//Console message #2
console.log("e1 nickname=" + e1.nickName);

//Console message #3
console.log("e2 nickname=" + e2.nickName);
e2.firstName = "Jane";
e2.lastName = "Smith";

//Console message #4
console.log("e1 full name=" + e1.fullName);
let e3 = e2;
e2.position = "manager";

//Console message #5
console.log("e3 position=" + e3.position);
```

A. e2 nickname = liz

B. e1 nickname = liz

C. e3 position = developer

D. e1 full name = Elizabeth Doe

E. full name:Elizabeth Doe,position: developer

A B E

在执行以下 JavaScript 代码后，控制台将显示哪些消息？

Console message #1: 显示 e1 的 fullName 和 position。因为 e1 已经被正确初始化并设置了 position，所以将输出"full name: Elizabeth Doe, position: developer"。
Console message #2: 显示 e1 的 nickName。由于 e1 和 e2 指向同一个对象，且 nickName 最后被设置为"Liz"，所以输出为"e1 nickname=Liz"。
Console message #3: 显示 e2 的 nickName。因为 e1 和 e2 引用的是同一个对象，且 nickName 最后设置为"Liz"，所以输出与#2 相同，为"e2 nickname=Liz"。
Console message #4: 显示 e1 的 fullName。由于 e1 和 e2 引用同一个对象，且 firstName 和 lastName 被更改为"Jane"和"Smith"，所以输出为"e1 full name=Jane Smith"。
Console message #5: 显示 e3 的 position。因为 e3 也被赋值为 e2 所引用的对象，且 position 最后被设置为"manager"，所以输出为"e3 position=manager"。

#### 37

Which of the following modifications to the JavaScript code below protect against cross-site scripting (XsS) attacks (line numbers are for reference purposes only)?

```HTML
  <body>
    <button id="req-button" type="button">
      Make a request
    </button>
    <div id="content-div"></div>
    <script>
    (function () {
      var req;
      var url = "http://externalsite.com/public-data/";

      document.getElementById("req-button").addEventListener("click", makeRequest);

      function makeRequest() {
        req = new XMLHttpRequest();
        if (!req) {
          alert("cannot create a request instance");
          return false;
        }
        req.onreadystatechange = handler;
        req.open("GET", url, true);
        req.send();
      }

      function handler() {
        if (reg.readystate === XMLHttpRequest.DONE) {
          if (eq - status == 200) {
            var link = // 26
              '<a href"' +
              req.responseText.url +
              '">' +
              req.responseText.title +
              "</a>"; // 26
            document.getElementById("content-div").innerHTML = link; // 27
          } else { // 29
            alert("There was a problem with the request."); // 30
          } // 31
        }
      }
    })()
    </script>
  </body>
```

A. Replace Lines 26 and 27 with:

```tsx
var anchor = document.createElement("a");
var anchorText = document.createTextNode("req.responseText.title");
anchor.setAttribute("href", "req.responseText.url");
anchor.appendChild(anchorText);
document.getElementById("content-div").appendChild(anchor);
```

B. Delete Lines 29-31.

C. Replace Lines 30 and 31 with:

```tsx
var obj = (
  <object
    type="application/javascript"
    data="reg.responseText.url"
    value="req.responseText.title"
    width="100"
    height="20"
  />
);
document.getElementById("content-div").innerText = obj;
```

D. Replace Line 26 with;

```tsx
var link = (
  <link
    crossorigin="use-credentials"
    href="req.responseText.url"
    title="req.responseText.title"
  />
);
```

E. Replace Line 30 with:

```tsx
alert(req, responseText);
```

A

以下对 JavaScript 代码的哪些修改可以防止跨站脚本（XSS）攻击（行号仅供参考）？

A 的代码有小问题，应该改为如下，其他答案错的太离谱

```tsx
var anchor = document.createElement("a");
var anchorText = document.createTextNode(req.responseText.title);
anchor.setAttribute("href", req.responseText.url);
anchor.appendChild(anchorText);
document.getElementById("content-div").appendChild(anchor);
```

#### 38

Which of the following correctly describe when to call hooks in React?

A. From React function components

B. From a class

C. From regular JavaScript functions

D. From custom hooks

E. At the top level but not inside loops, conditions, or nested functions

A D E

以下哪些选项正确地描述了在 React 中何时调用 hooks？

A. 从 React 函数组件中

B. 从一个类中

C. 从常规的 JavaScript 函数中

D. 从自定义 hooks 中

E. 在顶层但不在循环、条件或嵌套函数内部

regular [ˈreɡjələr] 定时的，定期的;经常的;恒常的，常规的，

#### 39

There is a request to perform a sort on a complex object avaScript array before mounting a React js component that is a collection of divs.
Which of the following actions ensure the object array is sorted properly before the component finishes loading?

A. Override the shouldComponentUpdate() event and perform the sort of the object array.

B. Export the React.js component, which will automatically sort the object array.

C. Perform the sort within the componentWillMount() lifecycle event.

D. Sort the object array prior to the component's initialization and pass the array in as a property.

E. Create an anonymous function within the component that performs the sort regardless of lifecycle event.

#### 40

Which of the following correctly describe the JSX concepts portrayed in the React.js snippet below?

```tsx
import React from "react";
const DateComponents = {
  FarEastDateTime: function FarEastDateTime(props) {
    return <div>{this.props.date}</div>;
  },

  NorthAmericaDateTime: function NorthAmericanDateTime(props) {
    return <div>{this.props.date}</div>;
  },

  SouthAmericaDateTime: function SouthAmericanDateTime(props) {
    return <div>{this.props.date}</div>;
  },
  EuropeDateTime: function EuropeDateTime(props) {
    return <div>{this.props.date}</div>;
  },
};
function BlueDatePicker() {
  return <DateComponents.NorthAmericaDateTime date="12/01/2017" />;
}
```

A. Strict mode

B. Static type checking

C. Code-splitting

D. Dot notation for Jsx type

E. High-order components

D

以下哪些选项正确地描述了下面 React.js 代码片段中描绘的 JSX 概念？

A. 严格模式

B. 静态类型检查

C. 代码分割

D. 用于 JSX 类型的点表示法

E. 高阶组件

正确答案是 D，因为这个问题主要关注的是 JSX 和 React 组件的语法和用法。现在，我将逐一解释每个选项，并解释为什么选择 D。

A. Strict mode - 严格模式在 React 中是一种帮助识别潜在问题的工具，比如不安全的生命周期方法的使用等。但在此代码片段中，并没有显式地使用React.StrictMode组件，因此这个选项不正确。

B. Static type checking - 静态类型检查是 TypeScript（TSX）或 Flow 等工具提供的功能，用于在编译时捕获类型错误。虽然这个代码片段使用了.tsx 扩展名，但它并没有展示任何静态类型检查的特性（如类型注解），因此这个选项也不正确。

C. Code-splitting - 代码分割是一种优化技术，用于将应用拆分成多个较小的块，以便可以按需加载。这个代码片段没有展示任何与代码分割相关的内容，因此这个选项不正确。

D. Dot notation for JSX type - 这个选项是正确的，因为代码中使用了点表示法（.）来引用 DateComponents 对象中的 NorthAmericaDateTime 组件。这是 JSX 中引用嵌套或对象内组件的常用方法。

E. High-order components (HOC) - 高阶组件是 React 中的一个高级概念，用于复用组件逻辑。它们不是组件，而是函数，接收一个组件并返回一个新的组件。这个代码片段中没有使用高阶组件，因此这个选项不正确。

#### 41

A React.js sports score application captures a sports data API's responses using a fetch APl call inside of
the componentDidMount() lifecycle event. However, the JSON response causes an error when inserted into a component,
Using PropTypes, which of the following correctly describe how to validate the response object when it is inserted as a property into a component?

A. Set up a data object that models the response JSON and display warnings/errors within the browser console:

```tsx
import PropTypes from "prop-types";
const ResponseSportsPropTypes = {
  name: PropTypes.string,
  description: PropTypes.string,
  score: number,
};
PropTypes.checkPropTypes(
  ResponseSportsPropTypes,
  SportsResponse,
  "prop",
  "SportsComponent"
);
```

B. Set up a data object that models the response JSON and create new HTML logging markup:.

```tsx
import PropTypes from "prop-types";
const ResponseSportsPropTypes = {
  name: PropTypes.string,
  description: PropTypes.string,
  score: number,
};
PropTypes.checkPropTypes(
  ResponseSportsPropTypes,
  SportsResponse,
  "prop",
  "SportsComponent"
);
```

C. Set up a data object that models the response JSON and invoke a JavaScript debugger breakpoint

```tsx
import PropTypes from "prop-types";
const ResponseSportsPropTypes = {
  name: PropTypes.string,
  description: PropTypes.string,
  score: number,
};
PropTypes.checkPropTypes(
  ResponseSportsPropTypes,
  SportsResponse,
  "prop",
  "SportsComponent"
);
```

D. Set up a data object that models the response JSON and invoke JavaScript alert messages:

```tsx
import PropTypes from "prop-types";
const ResponseSportsPropTypes = {
  name: PropTypes.string,
  description: PropTypes.string,
  score: number,
};
PropTypes.checkPropTypes(
  ResponseSportsPropTypes,
  SportsResponse,
  "prop",
  "SportsComponent"
);
```

E. Validate the response but limit to displaying errors:

```tsx
import PropTypes from "prop-types";
PropTypes.checkPropTypes({}, SportsResponse, "prop", "SportsComponent");
```

A

一个 React.js 体育比分应用程序在 componentDidMount()生命周期事件中通过 fetch API 调用捕获体育数据 API 的响应。
但是，当将 JSON 响应插入到组件中时，会导致错误。使用 PropTypes，以下哪些选项正确地描述了当响应对象作为属性插入到组件时如何验证它？

A. 设置一个模拟响应 JSON 的数据对象，并在浏览器控制台中显示警告/错误：

B. 设置一个模拟响应 JSON 的数据对象并创建新的 HTML 日志标记（此选项不正确，因为它与验证逻辑无关）

C. 设置一个模拟响应 JSON 的数据对象并调用 JavaScript 调试器断点（此选项不正确，因为它与验证逻辑无关）

D. 设置一个模拟响应 JSON 的数据对象并调用 JavaScript 警告消息（此选项不正确，因为它与验证逻辑无关）

E. 验证响应但仅限于显示错误（此选项未提供具体的验证逻辑，且格式不正确）

#### 42

A developer must display an HTML entity inside JSX but it is not displaying correctly.
Which of the following will correct the issue in the code snippet below?

```tsx
<div>{"First &middot; Second"}</div> // Displays "First &middot;second"
```

A. Write a Unicode character directly in JavaScript:

```tsx
<div>{"First · Second"}</div>
```

B. Use mixed arrays with strings and JSX elements:

```tsx
<div>{["First ", <span>&middot;</span>, " Second"]}</div>
```

C. Escape the character with a backslash:

```tsx
<div>{"First &middot; second"}</div>
```

D. Find the Unicode number and use it inside the JavaScript string:

```tsx
<div>{"First \u00b7 second"}</div>
```

E. Put the character inside parentheses

```tsx
<div>{"First (&middot;) second"}</div>
```

A B D

开发者必须在 JSX 中显示一个 HTML 实体，但它没有正确显示。以下哪项将修正下面代码段中的问题？

A. 直接在 JavaScript 中写入 Unicode 字符：

B. 使用包含字符串和 JSX 元素的混合数组：

C. 使用反斜杠转义字符：

D. 查找 Unicode 编号并在 JavaScript 字符串中使用它：

E. 将字符放在括号内：

解释：

A. 直接在 JavaScript 中写入 Unicode 字符：
这是正确的，因为直接将&middot;替换为它的 Unicode 字符·可以在 JSX 中正确渲染中点，而不需要依赖 HTML 实体的解析。

B. 使用包含字符串和 JSX 元素的混合数组：
这也是一个有效的解决方案。通过将中点作为 JSX 元素<span>&middot;</span>与字符串拼接，可以确保中点以 HTML 的形式被渲染，从而正确显示。

C. 使用反斜杠转义字符：
这是不正确的。在这个上下文中，使用反斜杠\转义&会导致&middot;被视为普通文本的一部分，而不是 HTML 实体，因此中点不会正确显示。

D. 查找 Unicode 编号并在 JavaScript 字符串中使用它：
这是正确的。通过在字符串中使用 Unicode 编号\u00b7 来表示中点，可以确保字符被正确渲染。

E. 将字符放在括号内：
这是不正确的。将&middot;放在括号内并不会改变它在 JSX 中的解析方式，它仍然会被视为普通文本，而不是 HTML 实体。

#### 43

Which of the following strategies defend against DOM-based cross-site scripting (XSS) attacks in JavaScript?

A. Add a reCAPTCHA system to the website.

B. Use JavaScript encoding when inserting dynamic data into the event handler subcontext within an execution context.

C. Avoid writing server-side code that generates HTML pages with DOM objects.

D. Avoid using client-side data for sensitive actions such as modifying the DOM or redirection.

E. Perform a server-side code review of outbound URL parameters to prevent restricted web pages from being served.

B D

以下哪些策略可以防御 JavaScript 中的基于 DOM 的跨站脚本（XSS）攻击？

A. 在网站上添加 reCAPTCHA 系统。

B. 在执行上下文的事件处理器子上下文中插入动态数据时，使用 JavaScript 编码。

C. 避免编写生成包含 DOM 对象的 HTML 页面的服务器端代码。

D. 避免使用客户端数据执行敏感操作，如修改 DOM 或重定向。

E. 对出站 URL 参数执行服务器端代码审查以防止受限网页被提供。

strategies 战略;策略;规划;行动计划;部署;策划;战略部署;计策;统筹安排 [ˈstrætədʒiz]

解释：

B. 当在执行上下文的事件处理器子上下文中插入动态数据时，使用 JavaScript 编码：这是防御基于 DOM 的跨站脚本（XSS）攻击的一种有效策略。通过在将数据插入 DOM 之前进行适当的编码或转义，可以防止攻击者注入恶意脚本。这种方法特别适用于那些直接受用户输入影响的 JavaScript 代码区域，如事件处理函数中的动态内容。

D. 避免使用客户端数据执行敏感操作，如修改 DOM 或重定向：这也是一种重要的防御策略。当使用客户端数据（尤其是未经验证或转义的数据）来执行如修改 DOM 结构或进行页面重定向等敏感操作时，恶意用户可能会注入恶意脚本以操纵这些操作。因此，应避免直接使用来自用户的数据进行这些操作，或者在使用之前进行严格的验证和清理。

不选其他选项的原因：

A. 在网站上添加 reCAPTCHA 系统：虽然 reCAPTCHA 是一种防止自动化工具和恶意软件滥用的有效手段，但它主要用于阻止自动化表单提交，而不是直接防止 XSS 攻击。因此，它不能作为对抗 DOM-based XSS 的直接策略。

C. 避免编写生成包含 DOM 对象的 HTML 页面的服务器端代码：这个选项的建议在实际中可能不太现实，因为许多现代 Web 应用都依赖于服务器端生成的 HTML 页面和 DOM 对象。更重要的是，这个选项没有直接解决如何安全地在客户端处理用户输入和动态数据的问题，这是防御 DOM-based XSS 的关键。

E. 对出站 URL 参数执行服务器端代码审查以防止受限网页被提供：这个选项与 DOM-based XSS 攻击的防御无直接关联。它更多地关注于保护服务器不被用于分发恶意内容或未授权的资源，而不是防止在客户端执行的恶意脚本。

#### 44

Which of the following correctly identify the result of executing the JavaScript code snippet below that uses the spread operator?

```tsx
const[x,y...remaining]=['a','b','c','d'];
console.log(remaining);
```

A. ['c','d’]

B.'C'

C. Undefined

D. Nu11

E. TypeError

A

以下哪个选项正确地识别了使用扩展运算符执行的 JavaScript 代码片段的结果？

spread operator 展开操作符

spread [spred] 传播;（使）蔓延，扩散，散开;展开;使分散;延伸;涂;张开;打开;使散开;摊开;伸开;分（若干次）进行;

#### 45

Within a Reactjs banking application, the developer wants to pass the user's full name into a component
that is populated within a list of users. The component is used in multiple places within the entire application.
However, the full name does not update correctly.Based on the code snippet below,
which of the following corrections can remedy this situation?

```tsx
class UserWidget extends React.Component {
  constructor(props) {
    this.state = {
      fullName: `${props.firstName} ${props.lastName}`,
    };
  }
  render() {
    var fullName = this.state.fullName;
    var picture = this.props.picture;
    return (
      <div>
        <img src={picture} />
        <h2>{fu1lName}</h2>
      </div>
    );
  }
}
```

A. Pass the fullName into props as a parameter instead of two parameters and set them in state

```tsx
this.state = {
  fullName: `${props.fullName}`,
};
```

B.Use setstate to set the values within the constructor and set a function with

```tsx
return this.setState((state) => {
  return { fullName: `${props.firstName} ${props.lastName}` };
});
```

C. Use setstate to set the values within the constructor:

```tsx
this.setState({ fullName: `${props.firstName} ${props.lastName}` });
```

D. Set default values in state and do not use props as this is poor practice.

```tsx
this.state = { fullName: "" };
```

E. Define user props directly within the render method instead of adding them to state:

```tsx
var fullName = `${this.props.firstName} ${this.props.lastName}`;
```

E

在 Reactjs 银行应用程序中，开发者希望将用户的全名传递到一个组件中，该组件被填充在用户列表中。
该组件在整个应用程序的多个位置中使用。然而，全名没有正确更新。基于下面的代码片段，以下哪些更正可以解决这个问题？

A. 将 fullName 作为参数传入 props 并在 state 中设置：

B. 在构造函数中使用 setState 并设置一个函数：

C. 在构造函数中使用 setState：

D. 在 state 中设置默认值并不使用 props：

E. 直接在 render 方法中定义 user props 而不是添加到 state：

populated

remedy

poor practice

#### 46

Which of the following correctly map a JavaScript code snippet to a valid result
(line numbers in answers are for reference purposes only)?

A. Lne 6 displays [Function: Function]:

```tsx
class cls1 {
  constructor(name) {
    this.name = name;
  }
}
console.log(cls1.constructor); // 6
```

B. Lines 2 and 3 both display true:

```tsx
var obj2 = [];
console.log(obj2.prototype.constructor === Array); // 2
console.log(obj2.prototype === Array); // 3
```

C. Lines 2 and 3 both display [Function: object]:

```tsx
var obj3 = new Object();
console.log(obj3.prototype.constructor);
console.log(obj3.constructor);
```

D. Line 2 displays true

```tsx
var obj = {};
console.log(obj.constructor === Object); // 2
```

E. Line 10 displays true:

```tsx
class cls {
  constructor(name) {
    this.name = name;
  }
}

cls.prototype.price = function (amt) {
  this.price = amt;
};
var c1 = new cls("toy");
console.log(typeof c1.prototype.price === "function"); // 10
```

A D

以下哪些选项正确地将 JavaScript 代码片段映射到有效结果（答案中的行号仅供参考）？

new 出来的对象没有 prototype，有只有'\_\_proto\_\_'constructor 有 prototype

#### 47

A list of show times must be periodically updated within a React.js music concert application.
However, the size of the list does not update on the DOM even though the array of concert times does update,
Which of the following can be added to the source code below that will assist the DOM to update?

```tsx
class ConcertTimesList extends React.Component {
  private showTimes: any;

  constructor(props) {
    super(props);
    this.listRef = React.createRef();
    this.state = { times: [] };
  }
  componentDidMount() {
    fetch("https://api.mydomain.com")
      .then((response) => response.json())
      .then((data) => {
        const timesList = data.map((time) => <li>{time}</li>);
        this.setState({ times: timesList });
      });
  }
  render() {
    return <div ref={this.listRef}>{this.state.times}</div>;
  }
}
```

A. Add the componentDidUpdate lifecycle method to enforce an update to the DOM after snapshot is passed:

```tsx
componentDidUpdate(prevProps, prevState, snapshot) {
  if (snapshot !== null) {
    const list = this.listRef.current;
    list.scrollTop = list.scrollHeight - snapshot;
  }
}
```

B. Add the getSnapshotBeforeUpdate lifecycle method to capture the previous properties before the update occurs on the DOM:

```tsx
getSnapshotBeforeUpdate(prevProps,prevState){
    if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
}
```

C. Update the state object using a direct value:

```tsx
componentDidMount(){
    fetch("https://api.mydomain.com")
      .then((response) => response.json())
      .then((data) => {
        const timesList = data.map((time) => <li>{time}</li>);
        this.state.times = timesList;
      });
}

```

D. Update the state object using the response promise of fetch:

```tsx
componentDidMount(){
    fetch("https://api.mydomain.com")
      .then((response) => {
        const timesList = data.map((time) => <li>(time)</li>);
        this.setState({ times: timesList });
      })
      .then((data) => {
        console.log("Data - " + JSON.stringify(data));
      });
}
```

E. Add the componentDidUpdate lifecycle method to enforce an update to the DOM after the list of concert times
has been received and update the list size accordingly:

```tsx
componentDidUpdate(prevProps,prevState){
    if (this.state.times != prevState.times) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - 5;
    }
}

```

E

在一个React.js音乐会应用程序中，必须定期更新表演时间列表。但是，尽管音乐会时间数组已经更新，但DOM中的列表大小并未更新。以下哪项可以添加到下面的源代码中，以帮助DOM进行更新？

A：添加componentDidUpdate生命周期方法来在快照传递后强制更新DOM：

B：添加getSnapshotBeforeUpdate生命周期方法来在DOM更新之前捕获之前的属性：

C：使用直接值更新状态对象：

D：使用fetch的响应承诺来更新状态对象：

E：添加componentDidUpdate生命周期方法来在音乐会时间列表被接收后强制更新DOM，并相应地更新列表大小：

accordingly  [əˈkɔːrdɪŋli] 因此


解释：
在给出的代码中，尽管concertTimes数组通过fetch请求得到了更新，并通过setState设置到了组件的状态中，但DOM没有反映出更新后的列表大小。这是因为组件的DOM并没有在状态更新后自动重新渲染。我们需要确保在状态更新后，如果与旧状态不同，DOM能够得到适当的更新。

A选项提到componentDidUpdate并带有snapshot参数，但snapshot参数在标准的React生命周期中并不是componentDidUpdate的参数，而是getSnapshotBeforeUpdate的返回值，因此A选项不正确。

B选项引入了getSnapshotBeforeUpdate，虽然这是一个用于在DOM更新之前捕获一些信息的生命周期方法，但它并不直接帮助解决DOM未更新的问题，而是用于在某些特定的渲染场景中捕获滚动位置等。此外，此选项中的props.list和this.props.list并不存在于提供的代码中，因此B选项不正确。

C选项试图直接更新this.state.times，但在React中，直接修改状态是违反React原则的，因为React不会知道状态已经被更改，从而不会触发重新渲染。应该使用this.setState()来更新状态，所以C选项不正确。

D选项的代码尝试在fetch的响应中直接使用data变量，但在内层.then函数中data变量并没有在该作用域内定义，此外，它错误地调用了this.setstate（应该是this.setState），且逻辑上应该先处理数据再更新状态，然后再进行其他操作（如日志记录），所以D选项不正确。

E选项通过componentDidUpdate正确地检测了times状态的变化，并在状态变化后执行了某些DOM操作（尽管这里的滚动位置设置为list.scrollHeight - 5可能不是最优的，但它展示了如何在状态更新后更新DOM的概念）。这是一个有效的解决方案，因为它确保了当状态变化时，组件的DOM也会相应更新。

题目和答案的中文翻译：




#### 48

The code below is for a login portal. After the user logs in, the Reactjs application should display a welcome message;
however, the message does not display and only shows an empty container.
Which of the following correctly describe how to resolve this issue?

```tsx
function ConfirmationBoxBorder(props) {
  return (
    <div
      className={"confirmationBoxBorder ConfirmationBoxBorder-" + props.color}
    ></div>
  );
}

function WelcomeDialog() {
  return (
    <ConfirmationBoxBorder color="red">
      <h1 className="Dialog-title">Welcome</h1>
      <p className="Dialog-message">Thank you for logging in!</p>
    </ConfirmationBoxBorder>
  );
}

ReactDOM.render(<WelcomeDialog />, document.getElementById("root"));
```

A. ConfirmationBoxBorder should be defined as React.component class:

```
class ConfirmationBoxBorder extends React.Component
```

B. ConfirmationBoxBorder should be defined as a consumable React.component class:

```tsx
export default classConfirmationBoxBorder extends React.Component
```

C. ConfirmationBoxBorder should be defined as a consumable React.Component class and invoke the class constructor with the passed in properties:

```tsx
export default class ConfirmationBoxBorder extends React.Component {
  constructor(props) {
    super(props);
  }
}
```

D. The ConfirmationBoxBorder component should contain a mappable lst of items that render from the passed props list

```tsx
function ConfirmationBoxBorder(props) {
  const useList = this.props.map((user) => <div>{user}</div>);
  return (
    <div
      className={
        ("ConfirmationBoxBorder ConfirmationBoxBorder-" + props.color)
      }
    >
      {userList}
    </div>
  );
}
```

E. Props.children is required for content to be displayed within the ConfirmationBoxBorder component

```tsx
{
  props.children;
}
```

E

以下代码是一个登录门户的。用户登录后，Reactjs 应用应该显示一个欢迎消息；然而，消息没有显示，只显示了一个空容器。以下哪些选项正确地描述了如何解决这个问题？

A. ConfirmationBoxBorder 应该被定义为 React.component 类：

B. ConfirmationBoxBorder 应该被定义为可消费的 React.component 类：

C. ConfirmationBoxBorder 应该被定义为可消费的 React.Component 类，并用传入的属性调用类构造函数：

D. ConfirmationBoxBorder 组件应该包含一个可通过传递的 props 列表映射的项列表

E. Props.children 是必要的，以便在 ConfirmationBoxBorder 组件内显示内容

consumable [kənˈsuːməbl] 供消耗的；会用尽的

D 没有this

#### 49

The Reactjs code below must be refactored to prevent unwanted re-rendering of the messages when the count value changes.
Which of the following actions accomplish this and still allow for the use of context?

```tsx
import React, { Component } from "react";
const AppContext = React.createContext();
class AppProvider extends Component {
  state = {
    number: 10,
    increment: () => {
      this.setState({ number: this.state.number + 1 });
    },
    message: " ",
    setMessage: () => {
      this.setstate({ message: "Hello from context" });
    },
  };
  render() {
    return (
      <AppContext.Provider value={this.state}>
        <CountDisplay />
        <CountButton />
        <Message />
        <Message />
      </AppContext.Provider>
    );
  }
}

class CountDisplay extends Component {
  render() {
    return (
      <AppProvider>
        <AppContext.Consumer>
          <h2>The count is:{count}</h2>
        </AppContext.Consumer>
      </AppProvider>
    );
  }
}

const CountButton = () => {
  <div>
    <AppContext.Consumer>
      {(context) => <button onclick={context.increment}>Increase Count</button>}
    </AppContext.Consumer>
  </div>;
};

const Message = () => {
  const getColor = () => {
    Math.floor(Math.random() ** 255);
  };
  const style = {
    color: `rgb(${getColor()},${getColor()},${getColor()})`,
  };

  return (
    <div>
      <AppContext.Consumer>
        <h4 style={style}>{message}</h4>
      </AppContext.Consumer>
    </div>
  );
};
```

A. Separate message and count into their own contexts (MessageContext and countContext) and wrap the respective components with their respective Providers.

B. Remove the Message component from the application

C. Add the hook useMemo() to the AppProvider and tell it to only give new values when count or message change

D. Remove the Count component from the application

E. Remove state/context from the AppProvider.

C

下面的Reactjs代码必须被重构，以防止当count值变化时消息的不必要重新渲染。以下哪些操作可以实现这一点，并且仍然允许使用context？

A. 将消息和计数分离到它们自己的context中（MessageContext和countContext），并用它们各自的Provider包裹相应的组件。

B. 从应用程序中移除Message组件

C. 在AppProvider中添加hook useMemo()，并告诉它仅在count或message变化时才给出新值

D. 从应用程序中移除Count组件

E. 从AppProvider中移除state/context


respective [rɪˈspektɪv] 分别的；各自的


解释：
A. Separate message and count into their own contexts (MessageContext and countContext) and wrap the respective components with their respective Providers.

这个选项是解决当前问题的一个有效方法。通过将message和count分离到它们自己的context中，并使用各自的Provider来包裹相关的组件，可以确保只有当相关context的值变化时，对应的组件才会重新渲染。这样可以避免当一个值（如count）变化时，不相关的组件（如显示message的组件）也进行不必要的重新渲染。
C. Add the hook useMemo () to the AppProvider and tell it to only give new values when count or message change.

虽然在这个具体的例子中，AppProvider是一个类组件，而不是函数组件，因此不能直接使用useMemo。但是，如果我们将AppProvider重构为函数组件或者在其内部的状态管理逻辑中使用useMemo（例如，在返回context value时使用），那么我们可以确保只有当count或message变化时，context的value才会更新，这有助于减少不必要的重新渲染。不过，由于AppProvider是类组件，这里的直接应用不可行，但概念上是正确的，可以通过其他方式（如shouldComponentUpdate或更改为函数组件）实现类似的效果。
错误选项：
B. Remove the Message component from the application

移除Message组件并不能解决问题，因为问题在于不必要的重新渲染，而不是组件的存在。
D. Remove the Count component from the application

类似地，移除Count组件并不能解决message组件的不必要重新渲染问题。
E. Remove state/context from the AppProvider.

移除AppProvider中的状态或context将完全破坏应用的功能，因为它依赖于这些状态来管理数据和跨组件通信。


#### 49

Which of the following statements describe the use 'f the code snippet below in TypeScript?
let myBoolean: string | boolean;

A.

B.

C.

D.

E.
